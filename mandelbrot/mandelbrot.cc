/**
mandelbrot.cc
================

The Mandelbrot set is generated by sampling complex numbers c
in the complex plane, and determining whether under iteration of the polynomial:

   z_(n+1) = c + z_n * z_n 

that the magnitude of z (written |z_n|) remains bounded however large n gets. 
Images of the Mandelbrot set are created such that each pixel corresponds to a
point c in the complex plane, and its colour depends on the number of
iterations n before the iteration diverges, where z0=c. The set of points
forming the boundary of this relation forms the distinctive and easily
recognisable fractal shape shown in the following image, 

**/

#include <complex>
#include <array>
#include <vector>
#include "NP.hh"

struct Mandelbrot
{
    static constexpr const int MAXITR = 255 ;
    static constexpr const double MAXZSQ = 4.0;
    static constexpr const int NX = 1280 ; 
    static constexpr const int NY = 720 ; 

    std::vector<double>  F ; 
    std::array<double,2> X ; 
    std::array<double,2> Y ; 
    NP*                  a ; 
    
    Mandelbrot(); 
    std::string desc() const ; 
}; 

inline Mandelbrot::Mandelbrot()
    :
    F(*U::GetEnvVec<double>("FOCUS","-0.7,0,0.84375")),    
    a(NP::Make<unsigned char>(NY,NX))
{
    assert( F.size() == 3 ); 
    double aspect = double(NX)/double(NY) ;
    X[0] = F[0] - F[2]*aspect ;  
    X[1] = F[0] + F[2]*aspect ; 
    Y[0] = F[1] - F[2] ; 
    Y[1] = F[1] + F[2] ; 

    a->set_meta<double>("xmin", X[0] ) ;
    a->set_meta<double>("xmax", X[1] ) ; 
    a->set_meta<double>("ymin", Y[0] ) ;
    a->set_meta<double>("ymax", Y[1] ) ; 
    unsigned char* aa = a->values<unsigned char>() ; 

    for(int iy=0;iy<NY;iy++) for(int ix=0;ix<NX;ix++) 
    {
        if(ix == 0 && (iy % 100 == 0)) std::cout << "iy " << iy << std::endl ; 

        double x = X[0] + double(ix)*(X[1]-X[0])/double(NX) ; 
        double y = Y[0] + double(iy)*(Y[1]-Y[0])/double(NY) ; 
        std::complex<double> c(x, y);
        std::complex<double> z(0.0, 0.0);
        unsigned char count = 0; 
        while((std::norm(z)<MAXZSQ) && (count < MAXITR-1 )) 
        {
            z=std::pow(z, 2) + c;
            count++;
        }
        if(count < MAXITR) aa[iy*NX+ix] = count ; 
    }
}

std::string Mandelbrot::desc() const 
{
    std::stringstream ss ; 
    ss << "Mandelbrot"
       << " F ( " << F[0] << "," << F[1] << "," << F[2] << ")"
       << " X ( " << X[0] << "," << X[1] << ")"
       << " Y ( " << Y[0] << "," << Y[1] << ")"
       ;
    std::string s = ss.str(); 
    return s ; 
}

int main()
{
    Mandelbrot m ; 
    m.a->save("$FOLD/a.npy"); 
    std::cout << m.desc() << std::endl ; 
    return 0 ; 
}


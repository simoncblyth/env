/**
Mandelbrot.cc
================

The Mandelbrot set is generated by sampling complex numbers c
in the complex plane, and determining whether under iteration of the polynomial:

   z_(n+1) = c + z_n * z_n 

that the magnitude of z (written |z_n|) remains bounded however large n gets. 
Images of the Mandelbrot set are created such that each pixel corresponds to a
point c in the complex plane, and its colour depends on the number of
iterations n before the iteration diverges, where z0=c. The set of points
forming the boundary of this relation forms the distinctive and easily
recognisable fractal shape shown in the following image, 
**/

#include "scuda.h"
#include "ssys.h"

#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
#include <complex>
#include <vector>

#include "NP.hh"
//#include "SIMG.hh"


struct Mandelbrot
{
    static constexpr const int MAXITR = 255 ;
    static constexpr const double MAXZSQ = 4.0;
    static constexpr const int NX = 1280 ; 
    static constexpr const int NY = 720 ; 

    std::vector<float>* focus ; 
    std::vector<float>* xdom ; 
    std::vector<float>* ydom ;

    float aspect ; 
    float2 center ; 
    float  extent ; 

    unsigned char* data  ; 
    
    Mandelbrot(); 
    std::string desc() const ; 

    void save(const char* path) const ; 

}; 

inline Mandelbrot::Mandelbrot()
    :
    focus(ssys::getenvvec<float>("FOCUS","0,0,0")),    
    xdom(ssys::getenvvec<float>("XDOM","-2.2,0.8")),    
    ydom(ssys::getenvvec<float>("YDOM","-1.5,1.5")),    
    data(new unsigned char[NY*NX])
{

    assert( focus->size() == 3 ); 
    assert( xdom->size() == 2 ); 
    assert( ydom->size() == 2 ); 
    assert( (*xdom)[1] > (*xdom)[0] ); 
    assert( (*ydom)[1] > (*ydom)[0] ); 

    aspect = ((*xdom)[1] - (*xdom)[0])/((*ydom)[1] - (*ydom)[0]) ; 
    center.x = (*focus)[0] ; 
    center.y = (*focus)[1] ; 
    extent = (*focus)[2] ; 

    if( extent > 0.f )  // after ana/pvplt.py 
    {
        float2 diagonal = make_float2( extent*aspect, extent ); 
        float2 botleft  = center - diagonal ; 
        float2 topright = center + diagonal ; 
        (*xdom)[0] = botleft.x ; 
        (*xdom)[1] = topright.x ; 
        (*ydom)[0] = botleft.y ; 
        (*ydom)[1] = topright.y ; 
        std::cout << " FOCUS override  " << desc() << std::endl ; 
    }

    for(int iy=0;iy<NY;iy++) for(int ix=0;ix<NX;ix++) 
    {
        if(ix == 0 && (iy % 100 == 0)) std::cout << "iy " << iy << std::endl ; 

        double x = (*xdom)[0] + double(ix)*((*xdom)[1]-(*xdom)[0])/double(NX) ; 
        double y = (*ydom)[0] + double(iy)*((*ydom)[1]-(*ydom)[0])/double(NY) ; 
        std::complex<double> c(x, y);
        std::complex<double> z(0.0, 0.0);
        unsigned char count = 0; 
        while((std::norm(z)<MAXZSQ) && (count < MAXITR-1 )) 
        {
            z=std::pow(z, 2) + c;
            count++;
        }
        if(count < MAXITR) data[iy*NX+ix] = count ; 
    }
}

std::string Mandelbrot::desc() const 
{
    std::stringstream ss ; 
    ss << "Mandelbrot"
       << " xdom ( " << (*xdom)[0] << " " << (*xdom)[1] << ")"
       << " ydom ( " << (*ydom)[0] << " " << (*ydom)[1] << ")"
       << " aspect " << aspect 
       ;
    std::string s = ss.str(); 
    return s ; 
}

void Mandelbrot::save(const char* path) const 
{
    NP* a = NP::Make<unsigned char>( NY, NX ); 
    a->read2( data ); 
    a->set_meta<float>("xmin", (*xdom)[0] ) ;
    a->set_meta<float>("xmax", (*xdom)[1] ) ; 
    a->set_meta<float>("ymin", (*ydom)[0] ) ;
    a->set_meta<float>("ymax", (*ydom)[1] ) ; 
    a->save(path); 

    //const char* pngpath = SIMG::ChangeExt(path, ".npy", ".png" ); 
    //SIMG img(NX, NY, 1, data) ; 
    //img.writePNG(pngpath); 
}

void test_uchar()
{
    unsigned char count = 0 ; 
    for(unsigned i=0 ; i < 256+10 ; i++ )
    {
       std::cout << " count " << int(count) << std::endl ; 
       count+=1 ; 
    }
}

int main(int argc, char** argv)
{
    Mandelbrot mb ; 
    const char* path = "/tmp/mandelbrot.npy" ; 
    mb.save(path); 
    std::cout << mb.desc() << std::endl ; 


    return 0 ; 
}

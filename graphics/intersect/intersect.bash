# === func-gen- : graphics/intersect/intersect fgp graphics/intersect/intersect.bash fgn intersect fgh graphics/intersect
intersect-src(){      echo graphics/intersect/intersect.bash ; }
intersect-source(){   echo ${BASH_SOURCE:-$(env-home)/$(intersect-src)} ; }
intersect-vi(){       vi $(intersect-source) ; }
intersect-env(){      elocal- ; }
intersect-usage(){ cat << EOU

INTERSECT : ray geometry intersection notes
=========================================================

A place for referencing sources and comparing implementations


See Also
---------

* csg- for tree serialization thoughts
* tboolean- 


Exceptional Sources
---------------------

Big table linking to varions intersection imps

* http://www.realtimerendering.com/intersections.html
* http://geomalgorithms.com/algorithms.html

* :google:`erit intersect`
* ~/opticks_refs/erit_intersection_collection.pdf 


Thoughts on partitioning, use if it simplifies
-------------------------------------------------

* OptiX primitives do not need to correspond to input solids...
  eg experience with analytic PMT

* Tessellation is partitioning taken to the extreme, 
  accel structures can efficiently cope with millions of triangles so do not 
  be coy about partitioning solids if that allows a simpler intersection 
  implementation.

  For example polycones could be partitioned at the z-planes leaving cone 
  intersections within a z range. Internally this is what the polycone 
  implementations do anyhow, treating them as separate primitives just shifts 
  the burden of locating which of the sub-polycone to OptiX accel structures 
  rather than the polycone implementation.

* fly in ointment of partitioning is boolean CSG, if the shape takes 
  part in boolean relations then cannot partition 
  because the boolean handling is done
  at intersect level beneath the OptiX primitive level


Line Cone
------------

* https://www.geometrictools.com/Documentation/IntersectionLineCone.pdf
* ~/opticks_refs/Eberly_IntersectionLineCone.pdf 

* https://www.csie.ntu.edu.tw/~cyy/courses/rendering/pbrt-2.00/html/cone_8cpp_source.html

  Quadratic approach


Surface of Revolution
-----------------------

A surface which can be generated by revolving a plane curve about an axis in its plane.

Ray tracing books mention symmetry use to intersect in 2D 
(project ray into plane of the generatrix)



* https://en.wikipedia.org/wiki/Surface_of_revolution

* :google:`ray intersection with surface of revolution`

* http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=934677

  * An Old Problem with a new perspective

* https://www.mathworks.com/matlabcentral/answers/73606-intersection-of-3d-ray-and-surface-of-revolution


Normal to a quadric surface
-----------------------------

Implicit unit sphere

   F(x,y,z) = 0 ;    x^2 + y^2 + z^2 - 1 = 0 

   Normal at [df/dx, df/dy, df/dz ] = [2x, 2y, 2z]  normalized -> [x,y,z]



Is Polycone a piecewise surface of revolution ?
--------------------------------------------------

::

    G4Polycone(const G4String& pName,
                 G4double  phiStart,
                 G4double  phiTotal,
                 G4int         numZPlanes,
                 const G4double  zPlane[],
                 const G4double  rInner[],
                 const G4double  rOuter[])

    G4Polycone(const G4String& pName, 
                 G4double  phiStart,
                 G4double  phiTotal,
                 G4int         numRZ,
                 const G4double  r[],
                 const G4double  z[])



* http://geant4.in2p3.fr/IMG/pdf_Lecture-Geometry.pdf

  * shows a polycone with convex parts, 
    (r,z) coords not with monotonic z ?  or used rInner > 0 for those sections


Intersections ray/cone
-------------------------

* https://www.geometrictools.com/Documentation/IntersectionLineCone.pdf
* https://www.csie.ntu.edu.tw/~cyy/courses/rendering/pbrt-2.00/html/cone_8cpp_source.html


hemi-pmt.cu is poor name, much more general now
------------------------------------------------

* analytic.cu is better, however this needs to be sliced into focussed headers

::

    simon:cu blyth$ opticks-find hemi-pmt.cu 
    ./bin/oks.bash:    ./optixrap/cu/hemi-pmt.cu
    ./optixrap/cu/hemi-pmt.cu:  rtPrintf("hemi-pmt.cu:bounds primIdx %d min %10.4f %10.4f %10.4f max %10.4f %10.4f %10.4f \n", primIdx, 
    ./ggeo/GParts.cc:    // see oxrap/cu/hemi-pmt.cu::intersect
    ./ggeo/GParts.cc:    // following access pattern of oxrap/cu/hemi-pmt.cu::intersect
    ./ggeo/GPmt.cc:which are used in cu/hemi-pmt.cu as the OptiX primitives
    ./optixrap/OGeo.cc:    geometry->setIntersectionProgram(m_ocontext->createProgram("hemi-pmt.cu.ptx", "intersect"));
    ./optixrap/OGeo.cc:    geometry->setBoundingBoxProgram(m_ocontext->createProgram("hemi-pmt.cu.ptx", "bounds"));
    ./ggeo/GParts.hh:        // allowing this to copied/used on GPU in cu/hemi-pmt.cu
    ./opticksnpy/NPrism.cpp:    // hmm more dupe of hemi-pmt.cu/make_prism
    ./opticksnpy/NTrianglesNPY.cpp:    // hmm how to avoid duplication between here and hemi-pmt.cu/make_prism
    ./optixrap/CMakeLists.txt:    cu/hemi-pmt.cu 
    ./optixrap/CMakeLists.txt:    ${CMAKE_CURRENT_BINARY_DIR}/${name}_generated_hemi-pmt.cu.ptx
    ./ana/pmt/geom.py:        see cu/hemi-pmt.cu for where these are used 
    simon:opticks blyth$ 





EOU
}
intersect-dir(){ echo $(local-base)/env/graphics/intersect/graphics/intersect-intersect ; }
intersect-cd(){  cd $(intersect-dir); }
intersect-mate(){ mate $(intersect-dir) ; }
intersect-get(){
   local dir=$(dirname $(intersect-dir)) &&  mkdir -p $dir && cd $dir

}

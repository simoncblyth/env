Meshlab Navigation
=====================

From examination of the collada importer, it seems that 
all shapes are getting appended into a single mesh. With 
a single bbox.

So no way to navigate to a subnode, unless:

#. calculate bbox during import 
#. transform the bbox min max with the appropriate transform, 
#. keep all the boxes in a structure keyed by node id

#. this will allow the camera to be steered to look at particular nodes

* /usr/local/env/graphics/meshlab/vcglib/vcg/space/box.h


Where to tack the structure ?
-------------------------------

Needs to go on MeshModel ?


GUI
-----
::

    simon:src blyth$ find . -name '*.cpp' -exec grep -H MeshDecorateInterface {} \;
    ./common/pluginmanager.cpp:        MeshDecorateInterface *iDecorator = qobject_cast<MeshDecorateInterface *>(plugin);
    ./meshlab/glarea.cpp:                   MeshDecorateInterface * decorInterface = qobject_cast<MeshDecorateInterface *>(p->parent());
    ./meshlab/glarea.cpp:           MeshDecorateInterface * decorInterface = qobject_cast<MeshDecorateInterface *>(p->parent());
    ./meshlab/layerDialog.cpp:              MeshDecorateInterface* decPlug =  qobject_cast<MeshDecorateInterface *>(decList[ii]->parent());
    ./meshlab/layerDialog.cpp:      MeshDecorateInterface* decPlug =  qobject_cast<MeshDecorateInterface *>(act->parent());
    ./meshlab/mainwindow_Init.cpp:  foreach(MeshDecorateInterface *iDecorate,PM.meshDecoratePlugins())
    ./meshlab/mainwindow_RunTime.cpp:       MeshDecorateInterface *iDecorateTemp = qobject_cast<MeshDecorateInterface *>(action->parent());
    ./meshlab/plugindialog.cpp:                MeshDecorateInterface *iDecorate = qobject_cast<MeshDecorateInterface *>(plugin);
    ./meshlab/plugindialog.cpp:             MeshDecorateInterface *iDecorate = qobject_cast<MeshDecorateInterface *>(plugin);
    simon:src blyth$ 


Controlling the camera
------------------------

/usr/local/env/graphics/meshlab/meshlab/src/meshlabplugins/decorate_background/decorate_background.cpp::

     85 bool SampleMeshDecoratePlugin::startDecorate( QAction * action, MeshDocument &/*m*/, RichParameterSet * parset, GLArea * gla)
     86 {
     87   switch(ID(action)){
     88     case DP_SHOW_CUBEMAPPED_ENV :
     89     if(parset->findParameter(CubeMapPathParam())== NULL) qDebug("CubeMapPath was not setted!!!");
     90       cubemapFileName = parset->getString(CubeMapPathParam());
     91     break;
     92   case DP_SHOW_GRID:
     93     connect(gla,SIGNAL(transmitShot(QString,vcg::Shotf)),this,SLOT(setValue(QString,vcg::Shotf)));
     94     connect(this,SIGNAL(askViewerShot(QString)),gla,SLOT(sendViewerShot(QString)));
     95   break;
     96   }
     97     return true;
     98 }

::

    100 void SampleMeshDecoratePlugin::decorate(QAction *a, MeshDocument &m, RichParameterSet * parset,GLArea *gla, QPainter * )
    101 {
    102   static QString lastname("unitialized");
    103     switch(ID(a))
    ...
    139   case DP_SHOW_GRID :
    140     {
    141       emit this->askViewerShot("me");
    142       Box3f bb=m.bbox();


header::

     96 
     97 signals:
     98   void askViewerShot(QString);
     99 
     100 public slots:
     101   void  setValue(QString name, vcg::Shotf val);
     102 
     103 };


The implementation for the signal is generated by the moc meta-object-compiler. It just looks for connections
and calls the slots presumably.

* http://stackoverflow.com/questions/1406940/how-signal-and-slots-are-implemented-under-the-hood


Lotsa interesting emits from glarea /usr/local/env/graphics/meshlab/meshlab/src/meshlab/glarea.cpp::

    1235 void GLArea::sendViewPos(QString name)
    1236 {
    1237 #ifndef VCG_USE_EIGEN
    1238     Point3f pos=  trackball.track.InverseMatrix() *Inverse(trackball.camera.model) *Point3f(0,0,0);
    1239 #else
    1240     Point3f pos=  Eigen::Transform3f(trackball.track.InverseMatrix()) * Eigen::Transform3f(Inverse(trackball.camera.model)).translation();
    1241 #endif
    1242     emit transmitViewPos(name, pos);
    1243 }
    1244 
    1245 void GLArea::sendSurfacePos(QString name)
    1246 {
    1247     qDebug("sendSurfacePos %s",qPrintable(name));
    1248     nameToGetPickPos = name;
    1249     hasToGetPickPos=true;
    1250 }
    1251 
    1252 void GLArea::sendViewDir(QString name)
    1253 {
    1254     Point3f dir= getViewDir();
    1255     emit transmitViewDir(name,dir);
    1256 }
    1257 
    1258 void GLArea::sendMeshShot(QString name)
    1259 {
    1260     Shotf curShot=this->md()->mm()->cm.shot;
    1261     emit transmitShot(name, curShot);
    1262 }
    1263 
    1264 void GLArea::sendMeshMatrix(QString name)
    1265 {
    1266     Matrix44f mat=this->md()->mm()->cm.Tr;
    1267     emit transmitMatrix(name, mat);
    1268 }
    1269 
    1270 void GLArea::sendViewerShot(QString name)
    1271 {
    1272     Shotf curShot=shotFromTrackball().first;
    1273     emit transmitShot(name, curShot);
    1274 }
    1275 void GLArea::sendRasterShot(QString name)
    1276 {
    1277     Shotf curShot = vcg::Shotf();
    1278     if (this->md()->rm() != NULL)
    1279         curShot = this->md()->rm()->shot;
    1280     emit transmitShot(name, curShot);
    1281 }
    1282 
    1283 void GLArea::sendCameraPos( QString name )
    1284 {
    1285     Point3f dir= trackball.camera.ViewPoint();
    1286     emit transmitCameraPos(name,dir);
    1287 }







#!/usr/bin/env python
"""
Usage::

    index.py 
    open http://localhost/env/presentation/index.html

OR::

    index.sh   # which does the above 

Change the descriptions by making changes to 
meta sections in the source .txt RST files
of form::

      .. meta:: 
         :description: (Jan 2020) Blah blah 


"""

from __future__ import print_function
import os, sys, logging, re, argparse
from lxml import etree
from dateutil.parser import parse
log = logging.getLogger(__name__)


mptn = re.compile("(?P<month>[a-z]*)(?P<year>\d{4})")


def parse_date(txt):
    dt = parse(txt, default=None)
    epo = int(dt.strftime("%s"))
    #print("txt:%s dt:%s epo:%s" % (txt,dt,epo))
    return epo

def extract_date_from_name(name):
    mm = mptn.search(name)
    if not mm: return 0
    d = mm.groupdict()
    txt = "%(month)s%(year)s" % d 
    return parse_date(txt)

bptn = re.compile("\((?P<inbrk>.*)\)")
def extract_date_from_desc(desc):
    bm = bptn.search(desc)
    if not bm: return 0
    d = bm.groupdict()
    txt = "%(inbrk)s" % d  
    return parse_date(txt)


class Doc(object):
    def __init__(self, path):
        if os.path.exists(path):
            meta = self.Meta(path)
        else:
            meta = {}
        pass
        self.meta = meta
        self.path = path 


class Html(Doc):
    @classmethod
    def Meta(cls, path):
        """
        :param path:
        :return d:
        """
        tree = etree.parse( file(path),  etree.HTMLParser() )
        root = tree.getroot()
        d = {}
        for meta in root.xpath("./head/meta[@name and @content]"): 
            name = meta.xpath("@name")[0]
            content = meta.xpath("@content")[0]
            d[name] = content
        pass
        return d

class Rst(Doc):
    @classmethod
    def Meta(cls, path):
        """
        :param path:
        :return d:
        """
        lines = map(str.strip,file(path).readlines())
        ptn = re.compile(":(?P<key>\S*): (?P<val>.*)$")
        d = {}
        META = ".. meta::"
        if not META in lines:
            return d
        pass
        imeta = lines.index(META)
        iblank = imeta + lines[imeta:].index("")
        for line in lines[imeta+1:iblank]:
            #print(line) 
            m = ptn.match(line)
            assert m, ("bad line", line)
            gd = m.groupdict()
            key = gd["key"]
            val = gd["val"]
            d[key] = val 
            pass
        pass
        #log.info("path %s lines %s d %s " % (path, len(lines), d))
        return d 



class Item(object):
    def __init__(self, name, idx):
  
        html = Html(idx.htmlpath(name))
        rst = Rst(idx.rstpath(name))

        meta = {}
        meta.update(html.meta)
        meta.update(rst.meta)
        desc = meta.get("description", "")

        date = extract_date_from_name(name)
        if date == 0 and desc != "":
            date = extract_date_from_desc(desc)
        pass

        self.desc = desc
        self.name = name
        self.date = date

    def _get_lines(self):
        l = []
        l.append("<li> <a href=\"%s.html\"> %s.html </a> %s </li>" % (self.name, self.name, self.desc))
        return l
    lines = property(_get_lines)

 
    def __str__(self):
        return "\n".join(self.lines) 


class Index(object):
    def __init__(self, base, srcbase):
        base = os.path.expandvars(os.path.expanduser(base))
        assert os.path.isdir(base), base
        srcbase = os.path.expandvars(os.path.expanduser(srcbase))
        assert os.path.isdir(srcbase), srcbase
        pass
        self.base = base 
        self.srcbase = srcbase 

        names = filter(lambda p:p.endswith(".html") and p != "index.html",os.listdir(self.base))
        names = map(lambda n:n[:-5], names)
        items = map(lambda name:Item(name, self), names )
        self.items = sorted(items, key=lambda item:item.date)

    def htmlpath(self, name):
        return os.path.join(self.base, "%s.html" % name)
    def rstpath(self, name):
        return os.path.join(self.srcbase, "%s.txt" % name)

    def write(self):
        path = os.path.join(self.base, "index.html")
        if os.path.exists(path):
            os.remove(path) 
        pass 
        log.info("writing to %s " % path)
        out = file(path, "w") 
        print(str(self), file=out) 

    def _get_lines(self):
        l = []
        l.append("<html>")
        l.append("<!-- generated by index.py -->")
        l.append("<!-- open http://localhost/env/presentation/index.html -->")
        l.append("<ul>")
        for item in self.items:
            l.extend(item.lines)
        pass
        l.append("</ul>")
        l.append("</html>")
        return l

    lines = property(_get_lines)
 
    def __str__(self):
        return "\n".join(self.lines) 




def parse_args(doc):
    parser = argparse.ArgumentParser(description=doc, formatter_class=argparse.RawDescriptionHelpFormatter)

    d = {}
    d["level"] = "INFO" 
    d["base"] = "~/simoncblyth.bitbucket.io/env/presentation" 
    d["srcbase"] = "~/env/presentation" 
    d["format"] = "%(asctime)-15s %(levelname)-7s %(name)-20s:%(lineno)-3d %(message)s"

    parser.add_argument('--base', default=d["base"], help='base directory')
    parser.add_argument('--srcbase', default=d["srcbase"], help='srcbase directory')
    parser.add_argument('--level', default=d["level"], help='log level')
    args = parser.parse_args()
    logging.basicConfig(level=getattr(logging, args.level.upper()), format=d["format"])
    return args

if __name__ == '__main__':

    args = parse_args(__doc__)
    idx = Index(args.base, args.srcbase)
    idx.write()




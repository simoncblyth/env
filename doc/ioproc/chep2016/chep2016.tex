\documentclass[a4paper]{jpconf}
\usepackage{graphicx}
\begin{document}
\title{Opticks : GPU Optical Photon Simulation for Particle Physics using NVIDIA\textregistered\ OptiX\texttrademark}

\author{Simon C Blyth}

\address{HEP Lab, Department of Physics, National Taiwan University, Taipei, Taiwan.}

\ead{simon.c.blyth@gmail.com}

\begin{abstract}
Opticks is an open source project that integrates the NVIDIA OptiX 
GPU ray tracing engine with Geant4 toolkit based simulations.
Massive parallelism brings drastic performance improvements with  
optical photon simulation speedup expected to exceed 1000 times Geant4 
when using workstation GPUs. Optical photon simulation time becomes 
effectively zero compared to the rest of the simulation.
Optical photons from scintillation and Cherenkov processes
are allocated, generated and propagated entirely on the GPU, minimizing 
transfer overheads and allowing CPU memory usage to be restricted to
optical photons that hit photomultiplier tubes or other photon detectors.
Collecting hits into standard Geant4 hit collections then allows the 
rest of the simulation chain to proceed unmodified.
Optical physics processes of scattering, absorption, reemission and 
boundary processes are implemented as CUDA OptiX programs based on the Geant4
implementations. Wavelength dependent material and surface properties as well as  
inverse cumulative distribution functions for reemission are interleaved into 
GPU textures providing fast interpolated property lookup or wavelength generation.
Geometry is provided to OptiX in the form of CUDA programs that return bounding boxes 
for each primitive and single ray geometry intersection results. Some critical parts 
of the geometry such as photomultiplier tubes have been implemented analytically 
with the remainder being tesselated. 
OptiX handles the creation and application of a choice of acceleration structures
such as boundary volume heirarchies and the transparent use of multiple GPUs. 
OptiX supports interoperation with OpenGL and CUDA Thrust that has enabled 
unprecedented visualisations of photon propagations to be developed 
using OpenGL geometry shaders to provide interactive time scrubbing and    
CUDA Thrust photon indexing to provide interactive history selection. 
Validation and performance results are shown for the photomultiplier based 
Daya Bay and JUNO Neutrino detectors. 
\end{abstract}

\section{Introduction}

A detailed understanding of the generation and propagation of optical 
photons is vital to the design, operation and analysis of photomultiplier
based neutrino detectors such as the Daya Bay~\cite{dyb} and JUNO\cite{juno} experiments. 
Detailed detector simulations are essential to develop such an understanding and the 
simulation provides crucial inputs to data analysis.  

% summarize (and reference) in a few lines the muon induced background discussion 
% from "Neutrino physics with JUNO"





Adoption of parallelism at various levels has become mandatory in order to 
fully exploit the capabilities of current computing hardware.  
CUDA is a parallel computing platform and application programming interface  
introduced by NVIDIA in 2006. Subsequently hundreds of millions of CUDA enabled GPUs 
in notebooks and workstations have been shipped driven mainly by consumer demand for
fast 3D graphics is computer games. 

% hmm dont mention MIC, as I know very little about it
% In contrast the recently introduces Intel MIC processors target high end workstations only.  
%Intel proposes the use of many integrated core (MIC) architecture coprocessors.

% too breathless ... relax, not an elevator pitch

Opticks works together with Geant4 replacing just the optical photon simulation with
an equivalent GPU simulation based on the NVIDIA OptiX ray tracing engine.
Opticks optical photon simulation uses ray tracing mega-kernels generated 
by the NVIDIA OptiX domain optimized just-in-time compiler from CUDA implementations
of optical scattering, absorption, boundary processes and scintillator reemission.

Massive GPU parallelism and state-of-the-art SBVH\cite{sbvh} geometry intersection acceleration structures
orchestrated with multi-level load balanced execution model using persistent threads 
combine to yield drastic performance improvements with an optical photon simulation speedup 
expected to exceed 1000 times Geant4 when using workstation GPUs. 
Near linear performance scaling with GPU cores across multiple GPUs is observed. 
In addition to removing the optical photon simulation bottleneck the CPU memory 
constraints are also removed as only photons that hit detectors need to 
consume CPU memory.

Development of GPU ray tracing algorithms remains an active area of research, NVIDIA OptiX

 
Direct application of hardware and software developed over the past 20 years 
to feed the demands
of the entertainment, gaming and design industries over the past 20 years 


  


\section{NVIDIA\textregistered OptiX\texttrademark}

NVIDIA\textregistered\ OptiX\texttrademark \cite{optixPaper} \cite{optixSite} 
is a general-purpose ray tracing engine designed for NVIDIA GPUs
that balances ease of use with performance by exposing a highly accessible 
single ray programming model while still remaining competitive with manually 
optimized custom approaches \cite{optixPaper} \cite{understanding}.  
The core principle of OptiX is a that ray tracing algorithms can be implemented 
from the combination of a small set of user provided programmable operations
into a ray tracing pipeline in a manner directly analogous to how OpenGL 
and Direct3D programmable shaders combine to create rasterization pipelines.
These operations are provided to OptiX in the form of CUDA programs \cite{cudaPaper} \cite{cudaURL} 
including: ray generation, object intersection and closest hit programs that operate on 
single rays. These programs together with a ray payload data structure are combined 
into a ray tracing kernel by a domain optimized Just-In-Time compiler.


Scene data is provided to OptiX via a high level node structure that 
Opticks constructs using the OptiX CPU side API. 
Geometry leaf nodes are assigned primitive counts 
and associated CUDA programs that return bounding box and 
report ray primitive intersection positions. 
The programs access GPU geometry buffers which are copied from the CPU at initialization.
Multiple geometry instance nodes are allowed to share geometry objects, this 
together with the use of transform nodes is used to model many thousands of  
photomultiplier tubes without repetition of information. This so called geometry 
instancing drastically reduces the GPU memory needed to contain the scene data.

The central data structure enabling fast ray tracing is a geometry index
known as an acceleration structure which sorts a scene’s primitives 
into spatial or object groups. 
Heirarchical tree structures are typically used
with leaves representing the primitives.  Rejection of higher level
volumes allows all contained volumes to be removed from the intersection
search. OptiX provides a simple interface to associate acceleration structures 
with different parts of a scene geometry but all the details of creation, updating 
and traversal are handled by OptiX internally using the geometrical information provided by the 
bounding box program. Opticks currently uses the SBVH structure\cite{SBVH}.



% workload scheduling across multiple GPUs 





\section*{References}
\begin{thebibliography}{9}


\bibitem{dyb}
An F et al.
2016
The detector system of the Daya Bay reactor neutrino experiment
{\it Nucl Instrum Methods} A {\bf 811} pp 133--161

\bibitem{juno}
An F et al.  
2016
Neutrino physics with JUNO
{\it J Phys G} {\bf 43} 030401

%\bibitem{freeLunchOver}
%Sutter H 2005
%{\it http://www.drdobbs.com/web-development/a-fundamental-turn-toward-concurrency-in/184405990}

\bibitem{g4A} 
Agostinelli S, Allison J, Amako K, Apostolakis J, Araujo H, Arce P, et al. 
2003  
Geant4--a simulation toolkit 
{\it Nucl Instrum Methods Phys Res} A {\bf 506} pp 250-–303 

\bibitem{g4B} 
Allison J, Amako K, Apostolakis J, Araujo H, Dubois P, Asai M, et al. 
2006 
Geant4 developments and applications 
{\it IEEE Trans Nucl Sci} {\bf 53} pp 270--8

\bibitem{g4C} 
Allison J, Amako K, Apostolakis J, Arce P, Asai M, Aso T, et al. 
2016 
Recent developments in Geant4 
{\it Nucl Instrum Methods Phys Res} A {\bf 835} pp 186--225


\bibitem{understanding}
Aila T and Laine S 
2009
Understanding the efficiency of ray traversal on GPUs
{\it Proceedings of the Conference on High Performance Graphics} pp 145--149


\bibitem{optixPaper} 
Parker S, Bigler J, Dietrich A, Friedrich H, Hoberock J, Luebke D, McAllister D, McGuire M, Morley K, Robison A and Stich M 
2010 
OptiX: a general purpose ray tracing engine
{\it ACM Trans. Graph. : Conf. Series} {\bf 29} p 66 

\bibitem{optixSite} 
NVIDIA{\textregistered} OptiX\texttrademark~ webpage {\tt https://developer.nvidia.com/optix}

\bibitem{optixGuide}
OptiX Programming Guide 3.0.0 {\tt http://developer.download.nvidia.com/assets/tools/files/optix/3.0.0/NVIDIA-OptiX-SDK-3.0.0-OptiX\_Programming\_Guide\_3.0.0.pdf}

\bibitem{sbvh}
Stich M, Friedrich H and Dietrich A 
2009
Spatial Splits in Bounding Volume Hierarchies


\bibitem{newton} 
Newton I 
1704 
Opticks: or, a treatise of the reflections, refractions, inflexions and colours of light.
{\it Printers to Royal Society, London} 

\bibitem{opticksURL} 
Opticks URL {\tt https://bitbucket.org/simoncblyth/opticks/}

\bibitem{g4daeURL} 
G4DAE URL {\tt https://bitbucket.org/simoncblyth/g4dae/}

\bibitem{numpy}
Van der Walt S, Colbert S, Varoquaux G 
2011 
The NumPy array: a structure for efficient numerical computation
{\it Comput. Sci. Eng.} {\bf 13} pp 22--30

\bibitem{cudaPaper}
Nickolls J, Buck I, Garland M and Skadron K 
2008
Scalable Parallel Programming with CUDA
{\it ACM Queue} {\bf 6} pp 40--53

\bibitem{cudaURL}
CUDA URL {\tt http://www.nvidia.com/object/cuda\_home\_new.html}

\bibitem{curandURL}
cuRAND URL {\tt http://docs.nvidia.com/cuda/curand/index.html}


\bibitem{thrust}
Bell N and Hoberock J 
2011
{\it Thrust: a Productivity-Oriented Library for CUDA}
(GPU Computing Gems Jade Edition) ed W W Hwu, Chapter 26   

\bibitem{thrustURL} 
Thrust URL {\tt https://developer.nvidia.com/thrust}

\bibitem{colladaURL}
COLLADA URL {\tt https://www.khronos.org/collada/}

\bibitem{opengl}
Shreiner D, Sellers G, Kessenich J, Licea-Kane B 
2013
{\it OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 4.3}


\bibitem{chromaURL} 
Chroma URL {\tt http://chroma.bitbucket.org}

\bibitem{chromaB} 
Seibert S and LaTorre A 
2011 
Fast optical monte carlo simulation with surface-based geometries using Chroma {\tt http://chroma.bitbucket.org/\_downloads/chroma.pdf}


\end{thebibliography}

\end{document}



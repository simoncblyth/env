\documentclass[a4paper]{jpconf}
\usepackage{graphicx}
\begin{document}
\title{Opticks : GPU Optical Photon Simulation for Particle Physics using NVIDIA\textregistered\ OptiX\texttrademark}

\author{Simon C Blyth}

\address{HEP Lab, Department of Physics, National Taiwan University, Taipei, Taiwan.}

\ead{simon.c.blyth@gmail.com}

\begin{abstract}
Opticks is an open source project that integrates the NVIDIA OptiX 
GPU ray tracing engine with Geant4 toolkit based simulations.
Massive parallelism brings drastic performance improvements with  
optical photon simulation speedup expected to exceed 1000 times Geant4 
when using workstation GPUs. Optical photon simulation time becomes 
effectively zero compared to the rest of the simulation.
Optical photons from scintillation and Cherenkov processes
are allocated, generated and propagated entirely on the GPU, minimizing 
transfer overheads and allowing CPU memory usage to be restricted to
optical photons that hit photomultiplier tubes or other photon detectors.
Collecting hits into standard Geant4 hit collections then allows the 
rest of the simulation chain to proceed unmodified.
Optical physics processes of scattering, absorption, reemission and 
boundary processes are implemented as CUDA OptiX programs based on the Geant4
implementations. Wavelength dependent material and surface properties as well as  
inverse cumulative distribution functions for reemission are interleaved into 
GPU textures providing fast interpolated property lookup or wavelength generation.
Geometry is provided to OptiX in the form of CUDA programs that return bounding boxes 
for each primitive and single ray geometry intersection results. Some critical parts 
of the geometry such as photomultiplier tubes have been implemented analytically 
with the remainder being tesselated. 
OptiX handles the creation and application of a choice of acceleration structures
such as boundary volume heirarchies and the transparent use of multiple GPUs. 
OptiX supports interoperation with OpenGL and CUDA Thrust that has enabled 
unprecedented visualisations of photon propagations to be developed 
using OpenGL geometry shaders to provide interactive time scrubbing and    
CUDA Thrust photon indexing to provide interactive history selection. 
Validation and performance results are shown for the photomultiplier based 
Daya Bay and JUNO Neutrino detectors. 
\end{abstract}



\section{Related Work}

\subsection{Chroma}

The Chroma project\cite{chromaURL}\cite{chromaB}  
implements both GPU ray tracing and optical photon simulation using CUDA kernels
that are launched via PyCUDA scripts. 
%A message queue server is provided 
%to facilitate use of Chroma functionality from C++ code.
The development of Opticks was made possible by  
the experience I gained from working with Chroma.

Ray tracing performance comparisons between NVIDIA OptiX and a 
fork of Chroma\cite{chromaFork} halted my work with Chroma.
In addition to performance other limitations of Chroma include:
lack of validation comparisons against Geant4, no support for multiple GPUs, 
memory inefficient photon handling requiring the copying of photons from CPU to GPU,
memory inefficient geometry handling due to lack of geometry instancing, python 
implementation makes integration with Geant4 and other C++ code inconvenient. 

\subsection{VecGeom and GeantV}

The GeantV\cite{GeantV} (Geant-Vector) project aims 
to develop an all-particle transport simulation package that is 
several times faster than Geant4. The principal approach investigated 
is the application of SIMD operations across vectors of multiple tracks 
collected from multiple events according to locality criteria, this necessitates 
the development of vectorised geometry algorithms.  
The VecGeom\cite{VecGeom} project aims to provide these algorithms and also 
to optimize the single particle scalar performance.
VecGeom also includes CUDA implementations of the geometry algorithms.
%
Currently Opticks implements its own CUDA/OptiX geometry algorithms
for the small number of solids required to provide an analytic description 
of Photomultiplier tubes. 
Adoption of VecGeom within Opticks is a possible future development.
%the use of advanced architectures including (GP)GPUs and
%Intel\textregistered\ Xeon Phi\textrademark\ coprocessors.

\subsection{JUNO Fast Simulation}

The implementation of a fast simulation of the JUNO central detector has 
been studied in\cite{junoFastSim} using the voxel method. The core
of the method is to build the connection between the visible energy
in a voxel and the response of the photomultiplier tubes.
Essentially the approach persists parameterized response distributions 
of scintillation photons obtained from a full Geant4 simulation which 
can be then sampled to form an approximation of the full simulation.
Cerenkov photon anisotropy prevents application of this approach.
The symmetry of the detector geometry greatly reduces the number of 
response distributions that need to be persisted. Details such as 
shadowing from support struts or other things that break the symmetry 
require increases in numbers of parameter binning.  

Fast simulation techniques do not provide an alternative to full simulation, 
they merely provide an approximation of the full simulation which trade 
simulation time with file input/output time and bookkeeping. 
  
\subsection{IceCube GPU Photon Propagation}

IceCube\cite{IceCubeGPU} has used GPU photon tracking in production, replacing 
a two-stage parameterized approach with full photon simulation. 



%For each bin of R-theta parameter space distributions of nPE and hit time
%are collected from a full simulation.



%
% target audience should know the below, so dont bother
%
%Adoption of parallelism at various levels has become mandatory in order to 
%fully exploit the capabilities of current computing hardware.  
%CUDA is a parallel computing platform and application programming interface  
%introduced by NVIDIA in 2006. Subsequently hundreds of millions of CUDA enabled GPUs 
%in notebooks and workstations have been shipped driven mainly by consumer demand for
%fast 3D graphics is computer games. 
%
%
%
% hmm dont mention MIC, as I know very little about it
% In contrast the recently introduces Intel MIC processors target high end workstations only.  
%Intel proposes the use of many integrated core (MIC) architecture coprocessors.
%
% too breathless ... relax, not an elevator pitch
% BELOW CAN GO IN CONCLUSION, NOT INTRODUCTION
%
%Opticks works together with Geant4 replacing just the optical photon simulation with
%an equivalent GPU simulation based on the NVIDIA OptiX ray tracing engine.
%Opticks optical photon simulation uses ray tracing mega-kernels generated 
%by the NVIDIA OptiX domain optimized just-in-time compiler from CUDA implementations
%of optical scattering, absorption, boundary processes and scintillator reemission.
%
%Massive GPU parallelism and state-of-the-art SBVH\cite{sbvh} geometry intersection acceleration structures
%orchestrated with multi-level load balanced execution model using persistent threads 
%combine to yield drastic performance improvements with an optical photon simulation speedup 
%expected to exceed 1000 times Geant4 when using workstation GPUs. 
%Near linear performance scaling with GPU cores across multiple GPUs is observed. 
%In addition to removing the optical photon simulation bottleneck the CPU memory 
%constraints are also removed as only photons that hit detectors need to 
%consume CPU memory.
%
%Development of GPU ray tracing algorithms remains an active area of research, NVIDIA OptiX
%Direct application of hardware and software developed over the past 20 years 
%to feed the demands of the entertainment, gaming and design industries over the past 20 years 
%
  

\section{Introduction}

\begin{itemize}
\item Optical Photon Simulation Problem
\item Hybrid Solution
\item Connection between Ray Traced Image Synth and Optical Photon Simulation
\item external simulation cost : "context" duplication of geometry, materials, surfaces
\item open source opticks\cite{opticksURL} \cite{newton}
\item Opticks requirements, CUDA capability 3.0
\end{itemize}

\subsection{Optical Photon Simulation Problem}

A detailed understanding of the generation and propagation of optical 
photons is vital to the design, operation and analysis of photomultiplier
based neutrino detectors such as the Daya Bay~\cite{dyb} and JUNO\cite{juno} experiments. 
Detailed detector simulations are essential to develop such an understanding and the 
simulation provides crucial inputs to data analysis.  

The Geant4 based JUNO simulation was found to expend more than 99\% of CPU time
 

A fundamental requirement of optical photon propagation is to compute 
the next boundary intersection of a ray in the direction of travel 
at each step of the propagation in a highly efficient manner.

Geant4 uses a solid based geometry model with volumes of particular shape and material, 
such as cylinders of acrylic, GdLS or water. These volumes form a tree of mother volumes 
containing non-intersecting daughter volumes which in turn contain their own daughters, and so on. 
The tree structure and containment condition limits the number of volumes which 
must be be interrogated in order to compute the next boundary intersection, as if the 
mother of a volume does not intersect then its daughters cannot.

%
% summarize (and reference) in a few lines the muon induced background discussion 
% from "Neutrino physics with JUNO"
%

\subsection{Hybrid Solution}

Optical photons produced by C+S processes, yield only PMT hits


\section{Geometry}

Optical photon simulation is limited by the calculation of track geometry intersections and normals.
Once the intersection points and surface normals are known the remainder of the 
simulation only requires generation of a few random numbers 

Geometry intersection typically limits simulation performance. Geometry model
determines techniques (and hardware) available to accelerate intersection.

\begin{itemize}
\item Geometry model implications, 
\item G4DAE Geometry Exporter, volume tree, use extensiblity of DAE to include material/surface props as function of wavelength
\item importing Geometry, assimpfork \cite{Assimp} \cite{AssimpFork}
\item surface based geometry (BREP) more natural for ray tracing 
\item Geometry model translation, volume to surface based geometry (4 indices attached to primitives) in/out G4LogicalBorderSurface
\item mesh fixing with OpenMesh\cite{OpenMesh}
\item geocache using NumPy serialization
\item geometry instancing mandatory
\item analytic primitives for PMT, manual approach 
\item material and surface properties in GPU textures
\end{itemize}

\section{Event}

\begin{itemize}
\item cuRAND random numbers, initialization stack workaround
\item generation of scintillation and Cerenkov photons from gensteps (explain: Geant4 process "stack")
\item GPU resident photons, all operations done on GPU: seeded (assigned gensteps), generated, propagated, indexed 
\item photon indexing with CUDA Thrust 
\item integrated Geant4/Opticks workflow
\item multi-event handling 
\end{itemize}

\section{Validation}

\begin{itemize}
\item CFG4: one executable doing two simulations: pure G4 and G4+Opticks 
\item G4 step recorder in Opticks event format
\item simple test geometries configured on commandline
\item fresnel, rainbow
\item compressed recording of propagation steps
\item frequency count chi2 distance, distrib chi2
\end{itemize}

\section{Visualisation}

\begin{itemize}
\item small number of VBOs for entire geometry, one for non-instanced, one for each case of instanced geometry
\item persistent viewpoint bookmarks 
\item composited OpenGL rasterized render and OptiX ray trace, using Z-depth calulated for each raytrace pixel.
\item OptiX/OpenGL/CUDA/Thrust interoperation, same GPU buffers shared
\item OpenGL based visualization, GLFW
\item OpenGL shaders
\item time scrubbing a propagation (geometry shader with time as input)
\item index enables interactive photon history selection
\item GUI using ImGui\cite{ImGui}
\item layered dependencies, visualization on non-CUDA capable GPUs
\end{itemize}


\section{Conclusion}

\begin{itemize}
\item performance comparison
\item performance factors so large they become irrelevant, its the reciprocal are interested in 
\end{itemize}


\section{Future Developments}

\begin{itemize}
\item boolean CSG on GPU
\item G4DAE integrated with Geant4
\end{itemize}



\section{NVIDIA\textregistered OptiX\texttrademark}

\begin{itemize}
\item linearity of ray tracing performance with CUDA cores, with figure
\end{itemize}


NVIDIA\textregistered\ OptiX\texttrademark \cite{optixPaper} \cite{optixSite} 
is a general-purpose ray tracing engine designed for NVIDIA GPUs
that balances ease of use with performance by exposing a highly accessible 
single ray programming model while still remaining competitive with manually 
optimized custom approaches \cite{optixPaper} \cite{understanding}.  
The core principle of OptiX is a that ray tracing algorithms can be implemented 
from the combination of a small set of user provided programmable operations
into a ray tracing pipeline in a manner directly analogous to how OpenGL 
and Direct3D programmable shaders combine to create rasterization pipelines.
These operations are provided to OptiX in the form of CUDA programs \cite{cudaPaper} \cite{cudaURL} 
including: ray generation, object intersection and closest hit programs that operate on 
single rays. These programs together with a ray payload data structure are combined 
into a ray tracing kernel by a domain optimized Just-In-Time compiler.


Scene data is provided to OptiX via a high level node structure that 
Opticks constructs using the OptiX CPU side API. 
Geometry leaf nodes are assigned primitive counts 
and associated CUDA programs that return bounding box and 
report ray primitive intersection positions. 
The programs access GPU geometry buffers which are copied from the CPU at initialization.
Multiple geometry instance nodes are allowed to share geometry objects, this 
together with the use of transform nodes is used to model many thousands of  
photomultiplier tubes without repetition of information. This so called geometry 
instancing drastically reduces the GPU memory needed to contain the scene data.

The central data structure enabling fast ray tracing is a geometry index
known as an acceleration structure which sorts a scene’s primitives 
into spatial or object groups. 
Heirarchical tree structures are typically used
with leaves representing the primitives.  Rejection of higher level
volumes allows all contained volumes to be removed from the intersection
search. OptiX provides a simple interface to associate acceleration structures 
with different parts of a scene geometry but all the details of creation, updating 
and traversal are handled by OptiX internally using the geometrical information provided by the 
bounding box program. Opticks currently uses the SBVH structure\cite{SBVH}.



% workload scheduling across multiple GPUs 





\section*{References}
\begin{thebibliography}{9}


\bibitem{dyb}
An F, et al.
2016
The detector system of the Daya Bay reactor neutrino experiment
{\it Nucl Instrum Methods} A {\bf 811} pp 133--161

\bibitem{juno}
An F et al.  
2016
Neutrino physics with JUNO
{\it J Phys G} {\bf 43} 030401

%\bibitem{freeLunchOver}
%Sutter H 2005
%{\it http://www.drdobbs.com/web-development/a-fundamental-turn-toward-concurrency-in/184405990}

\bibitem{g4A} 
Agostinelli S, Allison J, Amako K, Apostolakis J, Araujo H, Arce P, et al. 
2003  
Geant4--a simulation toolkit 
{\it Nucl Instrum Methods Phys Res} A {\bf 506} pp 250-–303 

\bibitem{g4B} 
Allison J, Amako K, Apostolakis J, Araujo H, Dubois P, Asai M, et al. 
2006 
Geant4 developments and applications 
{\it IEEE Trans Nucl Sci} {\bf 53} pp 270--8

\bibitem{g4C} 
Allison J, Amako K, Apostolakis J, Arce P, Asai M, Aso T, et al. 
2016 
Recent developments in Geant4 
{\it Nucl Instrum Methods Phys Res} A {\bf 835} pp 186--225


\bibitem{VecGeom}
Apostolakis J, Bandieramonte M, Bitzes G, Brun R, Canal P, Carminati F, et al. 
2015
Towards a high performance geometry library for particle-detector simulations
{\it J. Phys.: Conf. Series} {\bf 608} 012023
%http://iopscience.iop.org/article/10.1088/1742-6596/608/1/012023/pdf

\bibitem{GeantV}
Amadio G, Apostolakis J, Bandieramonte M, Bhattacharyya A, Bianchini C, Brun R, Canal P, et al.
2015
The GeantV project : preparing the future of simulation 
{\it J. Phys.: Conf. Series} {\bf 664} 072006


\bibitem{understanding}
Aila T and Laine S 
2009
Understanding the efficiency of ray traversal on GPUs
{\it Proceedings of the Conference on High Performance Graphics} pp 145--149


\bibitem{optixPaper} 
Parker S, Bigler J, Dietrich A, Friedrich H, Hoberock J, Luebke D, McAllister D, McGuire M, Morley K, Robison A and Stich M 
2010 
OptiX: a general purpose ray tracing engine
{\it ACM Trans. Graph. : Conf. Series} {\bf 29} p 66 

\bibitem{optixSite} 
NVIDIA{\textregistered} OptiX\texttrademark~ webpage {\tt https://developer.nvidia.com/optix}

\bibitem{optixGuide}
OptiX Programming Guide 3.0.0 available from {\tt https://developer.nvidia.com/optix}
%{\tt http://developer.download.nvidia.com/assets/tools/files/optix/3.0.0/NVIDIA-OptiX-SDK-3.0.0-OptiX\_Programming\_Guide\_3.0.0.pdf}

\bibitem{sbvh}
Stich M, Friedrich H and Dietrich A 
2009
Spatial Splits in Bounding Volume Hierarchies


\bibitem{newton} 
Newton I 
1704 
Opticks: or, a treatise of the reflections, refractions, inflexions and colours of light.
{\it Printers to Royal Society, London} 

\bibitem{opticksURL} 
Opticks URL {\tt https://bitbucket.org/simoncblyth/opticks/}

\bibitem{g4daeURL} 
G4DAE URL {\tt https://bitbucket.org/simoncblyth/g4dae/}

\bibitem{numpy}
Van der Walt S, Colbert S, Varoquaux G 
2011 
The NumPy array: a structure for efficient numerical computation
{\it Comput. Sci. Eng.} {\bf 13} pp 22--30

\bibitem{cudaPaper}
Nickolls J, Buck I, Garland M and Skadron K 
2008
Scalable Parallel Programming with CUDA
{\it ACM Queue} {\bf 6} pp 40--53

\bibitem{cudaURL}
CUDA URL {\tt http://www.nvidia.com/object/cuda\_home\_new.html}

\bibitem{curandURL}
cuRAND URL {\tt http://docs.nvidia.com/cuda/curand/index.html}


\bibitem{thrust}
Bell N and Hoberock J 
2011
{\it Thrust: a Productivity-Oriented Library for CUDA}
(GPU Computing Gems Jade Edition) ed W W Hwu, Chapter 26   

\bibitem{thrustURL} 
Thrust URL {\tt https://developer.nvidia.com/thrust}

\bibitem{colladaURL}
COLLADA URL {\tt https://www.khronos.org/collada/}

\bibitem{opengl}
Shreiner D, Sellers G, Kessenich J, Licea-Kane B 
2013
{\it OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 4.3}


\bibitem{chromaURL} 
Chroma URL {\tt http://chroma.bitbucket.org}

\bibitem{chromaB} 
Seibert S and LaTorre A 
2011 
Fast optical monte carlo simulation with surface-based geometries using Chroma {\tt http://chroma.bitbucket.org/\_downloads/chroma.pdf}

\bibitem{chromaFork} 
Fork of Chroma {\tt http://bitbucket.org/simoncblyth/chroma}

\bibitem{junoFastSim}
Lin T, Deng Z, Li W, Cao G, You Z and Li X
2016
Fast muon simulation in the JUNO central detector
{\it Chin. Phys. C} {\bf 40} 8 086201

\bibitem{IceCubeGPU}
Chirkin D
2013
Photon tracking with GPUs in IceCube
{\it Nucl Instrum Methods Phys Res} A {\bf 725} pp 141--143
%
% https://arxiv.org/abs/astro-ph/0702108
% https://arxiv.org/pdf/astro-ph/0702108v2.pdf

\bibitem{ImGui}
ImGui URL {\tt https://github.com/ocornut/imgui}

\bibitem{OpenMesh}
OpenMesh URL {\tt https://www.openmesh.org}

\bibitem{Assimp}
Assimp URL {\tt http://www.assimp.org}

\bibitem{AssimpFork}
Fork of Assimp supporting G4DAE extra optical properties {\tt https://github.com/simoncblyth/assimp}

\end{thebibliography}

\end{document}



cmt-vi(){     vi $(cmt-source) ; }
cmt-src(){    echo cmt-/cmt-.bash ; }
cmt-url(){    echo $(env-url)/$(cmt-src) ; }
cmt-source(){ echo ${BASH_SOURCE:-$ENV_HOME/$(cmt-src)} ; }
cmt-usage(){
   cat << EOU

    NB THIS IS FOR LIGHTWEIGHT FUNCTIONS ... WITHOUT STATE 


   == General CMT convenience functions ==

     cmt-cl  
        clean out *.sh *.csh Makefile

     cmt-i
        CMT envvars
    
     cmt--
        get into the CMT environment of the PWD, 
        or of a cmt subfolder if one exists



   == "env" as a cmt ensemble, hookup  ==


     cmt-sitereq   :   $(cmt-sitereq)

     cmt-gensitereq 
          emit to stdout the site requirements as gleaned from envvars such as containing 
         "_CMT" such as 
              ROOT_CMT=ROOT_prefix:/data/env/local/root/root_v5.21.04/root
   
     cmt-preq
         pre-requisites to generating the sitereq, such as ROOT_CMT setup 
        
     cmt-addpp
         adding to the CMTPROJECTPATH ... for tethered usage





   CMT : it takes two to tangle  ... 2 heirarcies 
   ================================================
   
      projects  : linked up in cmt/project.cmt files
      packages  : linked up in cmt/requirements files 

ARE THESE TRUE ?
      packages depend on other packages and only refer to other packages
      projects depend on other projects and only refer to other projects


      CMTPROJECTPATH can contain only projects ... not packages directly 



EOU


}



cmt-env(){ 
   elocal-
   cmt-cmt
}


cmt-cl(){  rm -f *.sh *.csh Makefile ; }
cmt-i(){   env | grep CMT ; }
cmt-wipe(){  
  local msg="=== $FUNCNAME :"
  local cnf=$CMTCONFIG 
  [ -z "$cnf" ] && echo $msg ERROR no cnf $cnf  && return 1
  [ ${#cnf} -lt 5 ] && echo $msg ERROR sanity check of cnf $cnf FAILED && return 1
 
  [ -d "$cnf" ]    && echo $msg deleting \"$cnf\"    && rm -rf "$cnf" 
  [ -d "../$cnf" ] && echo $msg deleting \"../$cnf\" && rm -rf "../$cnf" 

  cmt-cl
}
  


cmt--(){
   local msg="=== $FUNCNAME :"

   [ -d "cmt" ]      && echo $msg cd ==\> $PWD/cmt    &&  cd cmt
   [ "$(basename $PWD)" != "cmt" -a -d "../cmt" ]   && echo $msg cd ==\> $PWD/../cmt &&  cd ../cmt
   [ $(basename $PWD) != "cmt" ] && echo $msg ERROR this only works from cmt package directories, or siblings/parents of such dirs && return 1 
   [ ! -f setup.sh ] && echo $msg doing cmt config as no setup.sh && cmt config
   [ ! -f setup.sh ] && echo $msg ERROR failed to create setup.sh && return 1
   echo $msg getting into cmt environment at $PWD   try : cmt show macro whatever
   . setup.sh 
}


## purloin the NuWa CMT as identified by NUWA_HOME

cmt-ver(){      echo v1r20p20080222 ; }
cmt-setup(){    
   local ext=$(cmt-external) 
   [ -n "$ext" ] && echo $(cmt-external)/CMT/$(cmt-ver)/mgr/setup.sh || echo "" 
}
cmt-external(){ [ -n "$NUWA_HOME" ] && echo $(dirname $NUWA_HOME)/external || echo "" ; }   ## NUWA_HOME is an input to the nuwa machinery, it does not depend on that being run

cmt-addpp(){
   local add=$1;
   echo $CMTPROJECTPATH | grep -v $add - > /dev/null && export CMTPROJECTPATH=$add:$CMTPROJECTPATH
}


cmt-info(){
  cat << EOI

     cmt-ver      : $(cmt-ver)
     cmt-external : $(cmt-external)
     cmt-setup    : $(cmt-setup)
   


EOI
}





cmt-itself(){
  local msg="=== $FUNCNAME :"
  local cmtsetup=$(cmt-setup)
  [ ! -f "$cmtsetup" ] && echo $msg $(cmt-source) : ERROR no cmtsetup $cmtsetup && return 1 
  . $cmtsetup
} 

cmt-cmt(){
 
  cmt-itself
  cmt-preq
  local sitereq=$(cmt-sitereq)
  [ ! -f "$sitereq" ] && cmt-upsite

}

cmt-upsite(){
   local msg="=== $FUNCNAME :"
   local sitereq=$(cmt-sitereq)
   echo $msg WARNING \(re\)generating sitereq $sitereq 
   cmt-gensitereq > $sitereq
}


cmt-sitereq(){
  echo $ENV_HOME/externals/site/cmt/requirements 
}


cmt-preq(){
  root-
  export CMTPROJECTPATH=$(env-home)
  export VERBOSE=1
}

cmt-gensitereq(){
  echo "package site" 
  echo "# generated by $BASH_SOURE::$FUNCNAME on $(date) "
  env | grep _CMT | while read line ; do 
    local payload=${line/*=/}
    echo macro ${payload/:*/} \"${payload/#*:/}\"  
  done
}






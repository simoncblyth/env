
VRML2FILE Geometry Export
===========================

.. contents:: :local:


Objective
----------

Convert a Geant4 geometry into a surface based STL file format.

* :google:`Convert a Geant4 geometry into a surface based STL file format`
* :google:`ST-Viewer step tools GDML`


TODO
-----

#. prevent culling
#. chase export warnings
#. validation that complete geometry exported 
#. does workflow retain solid identity into resulting mesh ?

   * surface properties
   * material types
   * sensitive detectors

Alternatives to VRML2
------------------------

* :doc:`gdml`
* :doc:`other`


GiGa python export
--------------------

Export geometry by adding to `opw/fmcpmuon.py`, using inspiration from  :dybsvn:`source:dybgaudi/trunk/Simulation/DetSim/python/visdet.py`::

        #
        # tone down verbosity of G4RunManager, 
        # skipping the particle table dump for Verbosity less than 3
        # https://wiki.bnl.gov/dayabay/index.php?title=FAQ:How_to_turn_off_long_particle_listing%3F
        #
        from GiGa.GiGaConf import GiGa, GiGaRunManager
        giga = GiGa("GiGa")
        gigarm = GiGaRunManager("GiGa.GiGaMgr")
        gigarm.Verbosity = 2 

        #
        # geometry export attempt
        # 
        from GaussTools.GaussToolsConf import GiGaRunActionCommand
        grac = GiGaRunActionCommand("GiGa.GiGaRunActionCommand")
        grac.BeginOfRunCommands = [ 
             "/vis/open VRML2FILE",
             "/vis/drawVolume",
             "/vis/viewer/flush"
        ]    
        #from GiGa.GiGaConf import GiGa
        giga = GiGa()
        giga.RunAction = grac    
        giga.VisManager = "GiGaVisManager/GiGaVis"


VRML2 IndexFaceSet
-------------------

* http://accad.osu.edu/~pgerstma/class/vnv/resources/info/AnnotatedVrmlRef/ch2-26.htm#2.6.3
* http://cs.iupui.edu/~aharris/mm/vrml4/vrml4.html

meaning of `solid FALSE`
~~~~~~~~~~~~~~~~~~~~~~~~~

* http://stackoverflow.com/questions/5130443/vrml-indexed-faceset

*Faces are visible from both sides*, so it doesn't matter if they were defined
clockwise or counter-clockwise. That's the easy hack, but it doubles the number
of polygons that the viewer renders internally.

* http://www.lighthouse3d.com/vrml/tutorial/index.shtml?indfs

The solid field determines if the browser should draw both sides of a face or
just the front side. VRML assumes by default, solid is TRUE that the faces in
an IndexedFaceSet form a solid shape. In this case there is no need to draw the
back sides of each face. If solid is FALSE then the browser will draw both
sides of each face.



VRML2 .wrl inspection
-----------------------

Succeeded to create a .wrl::

    [blyth@belle7 20130820-1318]$ du -hs g4_00.wrl 
    82M     g4_00.wrl


::

    [blyth@belle7 20130820-1318]$ head -50 g4_00.wrl 
    #VRML V2.0 utf8
    # Generated by VRML 2.0 driver of GEANT4


    #---------- CAMERA
    Viewpoint {
            position 0 0 111042
    }

    #---------- SOLID: /dd/Structure/Sites/db-rock.1000
            Shape {
                    appearance Appearance {
                            material Material {
                                    diffuseColor 1 1 1
                                    transparency 0.7
                            }
                    }
                    geometry IndexedFaceSet {
                            coord Coordinate {
                                    point [
                                            18049.9 -809521 22890,
                                            -9108.86 -767540 22890,
                                            -51089.9 -794699 22890,
                                            -23931.1 -836680 22890,
                                            -23931.1 -836680 -15104.2,
                                            18049.9 -809521 -15104.2,
                                            -51089.9 -794699 -15104.2,
                                            -9108.86 -767540 -15104.2,
                                    ]
                            }
                            coordIndex [
                                    0, 1, 2, 3, -1,
                                    4, 5, 0, -1,
                                    0, 3, 4, -1,
                                    6, 4, 3, -1,
                                    3, 2, 6, -1,
                                    7, 6, 2, -1,
                                    2, 1, 7, -1,
                                    5, 7, 1, -1,
                                    1, 0, 5, -1,
                                    5, 4, 6, -1,
                                    6, 7, 5, -1,
                            ]
                            solid FALSE
                    }
            }
    #---------- SOLID: /dd/Geometry/Sites/lvNearSiteRock#pvNearHallTop.1000
            Shape {
                    appearance Appearance {
                            material Material {

With 12k solids::

    ...
    #---------- SOLID: /dd/Geometry/Pool/lvNearPoolDead#pvNearADE1DeadLegs#pvLegInDead:2#pvLegInDeadUnit.2
    #---------- SOLID: /dd/Geometry/Pool/lvNearPoolDead#pvNearADE1DeadLegs#pvLegInDead:3#pvLegInDeadUnit.3
    #---------- SOLID: /dd/Geometry/Pool/lvNearPoolDead#pvNearADE1DeadLegs#pvLegInDead:4#pvLegInDeadUnit.4
    #---------- SOLID: /dd/Geometry/Pool/lvNearPoolDead#pvNearADE2DeadLegs#pvLegInDead:1#pvLegInDeadUnit.1
    #---------- SOLID: /dd/Geometry/Pool/lvNearPoolDead#pvNearADE2DeadLegs#pvLegInDead:2#pvLegInDeadUnit.2
    #---------- SOLID: /dd/Geometry/Pool/lvNearPoolDead#pvNearADE2DeadLegs#pvLegInDead:3#pvLegInDeadUnit.3
    #---------- SOLID: /dd/Geometry/Pool/lvNearPoolDead#pvNearADE2DeadLegs#pvLegInDead:4#pvLegInDeadUnit.4
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab1.1001
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab2.1002
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab3.1003
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab4.1004
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab5.1005
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab6.1006
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab7.1007
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab8.1008
    #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab9.1009
    [blyth@belle7 20130820-1318]$ grep SOLID g4_00.wrl  | wc -l
    12229




G4VRML2FileViewer::SendViewParameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    116 void G4VRML2FileViewer::SendViewParameters ()
    117 {
    118   // Calculates view representation based on extent of object being
    119   // viewed and (initial) direction of camera.  (Note: it can change
    120   // later due to user interaction via visualization system's GUI.)
    121 
    122 #if defined DEBUG_FR_VIEW
    123       G4cerr << "***** G4VRML2FileViewer::SendViewParameters()\n";
    124 #endif
    125 
    126     // error recovery
    127     if ( fsin_VHA < 1.0e-6 ) { return ; }
    128 
    129     // camera distance
    130     G4double extent_radius = fSceneHandler.GetScene()->GetExtent().GetExtentRadius();
    131     G4double camera_distance = extent_radius / fsin_VHA ;
    132 
    133     // camera position on Z axis
    134     const G4Point3D&    target_point
    135       = fSceneHandler.GetScene()->GetStandardTargetPoint()
    136       + fVP.GetCurrentTargetPoint();
    137     G4double        E_z = target_point.z() + camera_distance;
    138     G4Point3D       E(0.0, 0.0, E_z );
    139 
    140     // VRML codes are generated below   
    141     fDest << G4endl;
    142     fDest << "#---------- CAMERA" << G4endl;
    143     fDest << "Viewpoint {"         << G4endl;
    144     fDest << "\t" << "position "           ;
    145     fDest                 << E.x() << " "  ;
    146     fDest                 << E.y() << " "  ;
    147     fDest                 << E.z() << G4endl ;
    148     fDest << "}" << G4endl;
    149     fDest << G4endl;
    150 
    151 }



G4VRML2FileViewer::DrawView
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

     70 void G4VRML2FileViewer::DrawView()
     71 {
     72 #if defined DEBUG_FR_VIEW
     73     G4cerr << "***** G4VRML2FileViewer::DrawView()" << G4endl;
     74 #endif
     75 
     76     fSceneHandler.VRMLBeginModeling() ;
     77 
     78         // Viewpoint node
     79         SendViewParameters();
     80 
     81     // Here is a minimal DrawView() function.
     82     NeedKernelVisit();
     83     ProcessView();
     84     FinishView();
     85 }








export settings
----------------

Need to avoid culling for a complete export.


::

    /vis/viewer/set/culling global false
    /vis/viewer/set/culling coveredDaughters false 


visualization/management/src/G4VisManager.cc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    650 void G4VisManager::CreateViewer (G4String name,G4String XGeometry) {
    651 
    652   if (!fInitialised) Initialise ();
    653 
    654   if (fpSceneHandler) {
    655     G4VViewer* p = fpGraphicsSystem -> CreateViewer (*fpSceneHandler, name);
    656 
    ...
    660     G4ViewParameters vp = p->GetViewParameters();
    661     vp.SetXGeometryString(XGeometry);
    662     p->SetViewParameters(vp); //parse string and store parameters
    ...
    680       } else {
    681     fpViewer = p;                             // Make current.
    682     fpSceneHandler -> AddViewerToList (fpViewer);
    683     fpSceneHandler -> SetCurrentViewer (fpViewer);
    684 
    685     if (fVerbosity >= confirmations) {
    686       G4cout << "G4VisManager::CreateViewer: new viewer created."
    687          << G4endl;
    688     }
    689 
    690     const G4ViewParameters& vp = fpViewer->GetViewParameters();
    691     if (fVerbosity >= parameters) {
    692       G4cout << " view parameters are:\n  " << vp << G4endl;
    693     }
    694
    695     if (vp.IsCulling () && vp.IsCullingInvisible ()) {
    696       static G4bool warned = false;
    697       if (fVerbosity >= confirmations) {
    698         if (!warned) {
    699           G4cout <<
    700   "NOTE: objects with visibility flag set to \"false\""
    701   " will not be drawn!"
    702   "\n  \"/vis/viewer/set/culling global false\" to Draw such objects."
    703   "\n  Also see other \"/vis/viewer/set\" commands."
    704              << G4endl;
    705           warned = true;
    706         }
    707       }
    708     }
    709     if (vp.IsCullingCovered ()) {
    710       static G4bool warned = false;
    711       if (fVerbosity >= warnings) {
    712         if (!warned) {
    713           G4cout <<
    714   "WARNING: covered objects in solid mode will not be rendered!"
    715   "\n  \"/vis/viewer/set/culling coveredDaughters false\" to reverse this."
    716   "\n  Also see other \"/vis/viewer/set\" commands."
    717              << G4endl;
    718           warned = true;
    719         }
    720       }

::

    /vis/sceneHandler/create VRML2FILE
    G4VisManager::SetCurrentGraphicsSystem: system now VRML2FILE
    Graphics system set to VRML2FILE
    New scene handler "scene-handler-0" created.
    /vis/viewer/create ! ! 600 

    G4VisManager::CreateViewer: new viewer created.
     view parameters are:
      View parameters and options:
      Drawing style: wireframe
      Auxiliary edges: invisible
      Representation style: polyhedron
      Culling: on
      Culling invisible objects: on
      Density culling: off 
      Culling daughters covered by opaque mothers: off 
      Section flag: false
      No cutaway planes
      Explode factor: 1 about centre: (0,0,0)
      No. of sides used in circle polygon approximation: 24
      Viewpoint direction:  (0,0,1)
      Up vector:            (0,1,0)
      Field half angle:     0   
      Zoom factor:          1
      Scale factor:         (1,1,1)
      Current target point: (0,0,0)
      Dolly distance:       0
      Light does not move with camera
      Relative lightpoint direction: (1,1,1)
      Actual lightpoint direction: (1,1,1)
      Derived parameters for standard view of object of unit radius:
        Camera distance:   1
        Near distance:     1e-06
        Far distance:      2
        Front half height: 1
      Default VisAttributes:
      G4VisAttributes: visible, daughters visible, colour: (1,1,1,1)
      linestyle: solid, line width: 1
      drawing style: not forced, auxiliary edge visibility: not forced
      line segments per circle: not forced.
      time range: (-1.79769e+308,1.79769e+308)
      G4AttValue pointer is zero, G4AttDef pointer is zero
      Default TextVisAttributes:
      G4VisAttributes: visible, daughters visible, colour: (0,0,1,1)
      linestyle: solid, line width: 1
      drawing style: not forced, auxiliary edge visibility: not forced
      line segments per circle: not forced.
      time range: (-1.79769e+308,1.79769e+308)
      G4AttValue pointer is zero, G4AttDef pointer is zero
      Default marker: G4VMarker: position: (0,0,0), world size: 0, screen size: 5
               fill style: no fill
               No Visualization Attributes
      Global marker scale: 1
      Global lineWidth scale: 1
      Marker not hidden by surfaces.
      Window size hint: 600x600
      X geometry string: 600x600
      Auto refresh: false
      Background colour: (0,0,0,1)
      Picking requested: false

    NOTE: objects with visibility flag set to "false" will not be drawn!
      "/vis/viewer/set/culling global false" to Draw such objects.
      Also see other "/vis/viewer/set" commands.

    /////////   end from G4VisManager::CreateViewer 

    New viewer "viewer-0 (VRML2FILE)" created.
    Issue /vis/viewer/refresh to see effect.
    /vis/scene/create
    New empty scene "scene-0" created.
    /vis/scene/add/volume world
    First occurrence of "Universe"
      found at depth 0,
      with a requested depth of further descent of <0 (unlimited),
      has been added to scene "scene-0".
    /vis/sceneHandler/attach
    Scene "scene-0" attached to scene handler "scene-handler-0.
      (You may have to refresh with "/vis/viewer/flush" if view is not "auto-refresh".)
    NOTE: For systems which are not "auto-refresh" you will need to
      issue "/vis/viewer/refresh" or "/vis/viewer/flush".
    /vis/viewer/refresh viewer-0
    Refreshing viewer "viewer-0 (VRML2FILE)"...
    ===========================================
    Output VRML 2.0 file: g4_00.wrl
    Maximum number of files in the destination directory: 100
      (Customizable with the environment variable: G4VRMLFILE_MAX_FILE_NUM)
    ===========================================


where is the export steered from
------------------------------------

::

    [blyth@cms01 source]$ find visualization -name '*.cc' -exec grep -H vis/drawVolume {} \;
    visualization/management/src/G4VisCommandsCompound.cc:  UImanager->ApplyCommand(G4String("/vis/drawVolume " + pvname));
    visualization/management/src/G4VisCommandsCompound.cc:////////////// /vis/drawVolume ///////////////////////////////////////
    visualization/management/src/G4VisCommandsCompound.cc:  fpCommand = new G4UIcmdWithAString("/vis/drawVolume", this);
    visualization/management/src/G4VisCommandsSceneAdd.cc:       << "\n  /vis/drawVolume " << name
    visualization/management/src/G4VisManager.cc:     "\n  Null scene pointer. Use \"/vis/drawVolume\" or"
    visualization/management/src/G4VisCommandsViewer.cc:    "\n  (or use compound command \"/vis/drawVolume\")."
    visualization/management/src/G4VisCommandsViewer.cc:    "\n  (or use compound command \"/vis/drawVolume\")."
    visualization/RayTracer/src/G4RayTracerSceneHandler.cc:  // "/vis/drawVolume"...

::

    170 ////////////// /vis/drawVolume ///////////////////////////////////////
    171 
    172 G4VisCommandDrawVolume::G4VisCommandDrawVolume() {
    173   G4bool omitable;
    174   fpCommand = new G4UIcmdWithAString("/vis/drawVolume", this);
    175   fpCommand->SetGuidance
    176     ("Creates a scene containing this physical volume and asks the"
    177      "\ncurrent viewer to draw it.  The scene becomes current.");
    178   fpCommand -> SetGuidance
    179     ("If physical-volume-name is \"world\" (the default), the main geometry"
    180      "\ntree (material world) is drawn.  If \"worlds\", all worlds - material"
    181      "\nworld and parallel worlds, if any - are drawn.  Otherwise a search of"
    182      "\nall worlds is made, taking the first matching occurence only.  To see"
    183      "\na representation of the geometry hierarchy of the worlds, try"
    184      "\n\"/vis/drawTree [worlds]\" or one of the driver/browser combinations"
    185      "\nthat have the required functionality, e.g., HepRep");
    186   fpCommand->SetParameterName("physical-volume-name", omitable = true);
    187   fpCommand->SetDefaultValue("world");
    188 }






export warnings
----------------

Total of ~220 warning lines.  

::

    120 Traversing scene data...
    121 BooleanProcessor::triangulateContour : could not generate a triangle (infinite loop)
    122 BooleanProcessor: boolean operation failed
    123 BooleanProcessor::triangulateFace : too small contour
    124 BooleanProcessor::triangulateContour : could not generate a triangle (infinite loop)
    125 BooleanProcessor: boolean operation failed
    126 BooleanProcessor::triangulateContour : could not generate a triangle (infinite loop)
    127 BooleanProcessor: boolean operation failed
    ...
    151 BooleanProcessor::triangulateContour : could not generate a triangle (infinite loop)
    152 BooleanProcessor: boolean operation failed
    153 BooleanProcessor::assembleFace(74) : could not find next edge of the contour
    154 BooleanProcessor: boolean operation failed
    155 BooleanProcessor::caseIE : unimplemented case
    156 BooleanProcessor::caseIE : unimplemented case
    ...
    218 BooleanProcessor::caseIE : unimplemented case
    219 BooleanProcessor: boolean operation failed
    220 BooleanProcessor::execute : unknown faces !!!
    221 BooleanProcessor: boolean operation failed
    222 BooleanProcessor::execute : unknown faces !!!
    223 BooleanProcessor: boolean operation failed
    224 BooleanProcessor::triangulateFace : too small contour
    225 BooleanProcessor::triangulateContour : could not generate a triangle (infinite loop)
    226 BooleanProcessor: boolean operation failed
    227 BooleanProcessor::execute : unknown faces !!!
    228 BooleanProcessor: boolean operation failed
    229 BooleanProcessor::caseIE : unimplemented case
    ...
    335 BooleanProcessor::caseIE : unimplemented case
    336 BooleanProcessor::caseIE : unimplemented case
    337 BooleanProcessor: boolean operation failed
    338 Viewer "viewer-0 (VRML2FILE)" refreshed.
    339   (You might also need "/vis/viewer/update".)
    340 /vis/viewer/update viewer-0
    341 Viewer "viewer-0 (VRML2FILE)" post-processing triggered.
    342 *** VRML 2.0 File  g4_00.wrl  is generated.


But from examining the `graphics_reps/src/BooleanProcessor.src`, the *boolean operation failed* 
marks PROCESSOR_ERROR returns from `HepPolyhedron BooleanProcessor::execute`.  
There are only 45 of those::

    simon:geant4 blyth$ grep boolean\ operation\ failed export.txt | wc -l
          45


export debugging
----------------

How to debug what solids cause the warnings?  The effect is likely to be missing geometry.  


export output
-----------------

.. literalinclude:: export.txt

booleanprocessor
~~~~~~~~~~~~~~~~~~

::

    [blyth@cms01 source]$ find . -name '*.*' -exec grep -H BooleanProcessor {} \;
    ./visualization/management/include/G4VSceneHandler.hh:  // Generic clipping using the BooleanProcessor in graphics_reps is
    ./visualization/OpenGL/src/G4OpenGLSceneHandler.cc:  // when the BooleanProcessor is up to it, abandon this and use
    ./visualization/OpenGL/src/G4OpenGLSceneHandler.cc:  // But...if not, when the BooleanProcessor is up to it...
    ./visualization/OpenGL/src/G4OpenGLViewer.cc:  // BooleanProcessor is up to it, abandon this and use generic
    ./graphics_reps/src/HepPolyhedron.cc:#include "BooleanProcessor.src"
    ./graphics_reps/src/HepPolyhedron.cc:static BooleanProcessor processor;
    ./graphics_reps/src/BooleanProcessor.src: * Name: BooleanProcessor                            Date:    10.12.99 *
    ./graphics_reps/src/BooleanProcessor.src://                       its members from the BooleanProcessor class ---
    ./graphics_reps/src/BooleanProcessor.src:  friend class BooleanProcessor;
    ./graphics_reps/src/BooleanProcessor.src:class BooleanProcessor {
    ./graphics_reps/src/BooleanProcessor.src:  BooleanProcessor() {}
    ./graphics_reps/src/BooleanProcessor.src:  ~BooleanProcessor() {}
    ./graphics_reps/src/BooleanProcessor.src:void BooleanProcessor::takePolyhedron(const HepPolyhedron & p,
    ./graphics_reps/src/BooleanProcessor.src: * Name: BooleanProcessor::takePolyhedron            Date:    16.12.99 *
    ./graphics_reps/src/BooleanProcessor.src:double BooleanProcessor::findMinMax()
    ./graphics_reps/src/BooleanProcessor.src: * Name: BooleanProcessor::findMinMax                Date:    16.12.99 *
    ./graphics_reps/src/BooleanProcessor.src:void BooleanProcessor::selectOutsideFaces(int & ifaces, int & iout)
    ./graphics_reps/src/BooleanProcessor.src: * Name: BooleanProcessor::selectOutsideFaces        Date:    10.01.00 *
    ./graphics_reps/src/BooleanProcessor.src:int BooleanProcessor::testFaceVsPlane(ExtEdge & edge)
     ...

scene scaling
~~~~~~~~~~~~~~

Blender has trouble with the large extent, maybe scaling can be done while still in G4

visualization/management/src/G4VSceneHandler.cc

::

    271 void G4VSceneHandler::AddPrimitive (const G4Scale& scale) {
    272 
    273   const G4double margin(0.01);
    274   // Fractional margin - ensures scale is comfortably inside viewing
    275   // volume.
    276   const G4double oneMinusMargin (1. - margin);
    277 
    278   const G4VisExtent& sceneExtent = fpScene->GetExtent();
    279 
    280   // Useful constants...
    281   const G4double length(scale.GetLength());
    282   const G4double halfLength(length / 2.);
    283   const G4double tickLength(length / 20.);
    284   const G4double piBy2(halfpi);
    285 
    286   // Get size of scene...
    287   const G4double xmin = sceneExtent.GetXmin();
    288   const G4double xmax = sceneExtent.GetXmax();
    289   const G4double ymin = sceneExtent.GetYmin();
    290   const G4double ymax = sceneExtent.GetYmax();
    291   const G4double zmin = sceneExtent.GetZmin();
    292   const G4double zmax = sceneExtent.GetZmax();



examine the g4_00.wrl comments 
--------------------------------

Comments provide the names of solids. 

::

    00001 #VRML V2.0 utf8
       02 # Generated by VRML 2.0 driver of GEANT4
       03 #---------- CAMERA
       04 #---------- SOLID: /dd/Structure/Sites/db-rock.1000
       05 #---------- SOLID: /dd/Geometry/Sites/lvNearSiteRock#pvNearHallTop.1000
       06 #---------- SOLID: /dd/Geometry/Sites/lvNearHallTop#pvNearTopCover.1000
       07 #---------- SOLID: /dd/Geometry/Sites/lvNearHallTop#pvNearTeleRpc#pvNearTeleRpc:1.1
       08 #---------- SOLID: /dd/Geometry/RPC/lvRPCMod#pvRPCFoam.1000
       09 #---------- SOLID: /dd/Geometry/RPC/lvRPCFoam#pvBarCham14Array#pvBarCham14ArrayOne:1#pvBarCham14Unit.1
       10 #---------- SOLID: /dd/Geometry/RPC/lvRPCBarCham14#pvRPCGasgap14.1000
       11 #---------- SOLID: /dd/Geometry/RPC/lvRPCGasgap14#pvStrip14Array#pvStrip14ArrayOne:1#pvStrip14Unit.1
       12 #---------- SOLID: /dd/Geometry/RPC/lvRPCGasgap14#pvStrip14Array#pvStrip14ArrayOne:2#pvStrip14Unit.2
       13 #---------- SOLID: /dd/Geometry/RPC/lvRPCGasgap14#pvStrip14Array#pvStrip14ArrayOne:3#pvStrip14Unit.3
    ...
    12227 #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab4.1004
    12228 #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab5.1005
    12229 #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab6.1006
    12230 #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab7.1007
    12231 #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab8.1008
    12232 #---------- SOLID: /dd/Geometry/Sites/lvNearHallBot#pvNearHallRadSlabs#pvNearHallRadSlab9.1009
    12233 #End of file.



The names are not distinct::

    simon:samples blyth$ grep ^# g4_00.wrl > comments.txt

    simon:samples blyth$ wc -l comments.txt 
    12233 comments.txt
    simon:samples blyth$ cat comments.txt | sort | uniq | wc -l 
        5646

All comments are SOLID apart from 4 lines, one of which is CAMERA::

    simon:samples blyth$ grep SOLID g4_00.wrl | wc -l 
       12229

All geometry use `IndexedFaceSet`::

    simon:samples blyth$ grep geometry g4_00.wrl | uniq
                    geometry IndexedFaceSet {

All material use `Material`::

    simon:samples blyth$ grep material g4_00.wrl | sort | uniq
                            material Material {



Writing polyhedron primitives
-------------------------------

::

    169 void G4VRML2SCENEHANDLER::AddPrimitive(const G4Polyhedron& polyhedron)
    170 {
    171 #if defined DEBUG_SCENE_FUNC
    172     G4cerr << "***** AddPrimitive(G4Polyhedron)" << "\n";
    173 #endif
    174 
    175     if (polyhedron.GetNoFacets() == 0) return;
    176 
    177     VRMLBeginModeling () ;
    178 
    179     // Transparency checking: If completely transparent, skip drawing
    180     if ( GetPVTransparency() > 0.99 ) { return ; }
    181 
    182     // Current Model
    183     const G4VModel* pv_model  = GetModel();
    184     G4String pv_name = "No model";
    185         if (pv_model) pv_name = pv_model->GetCurrentTag() ;
    186 
    187     // VRML codes are generated below
    188 
    189     fDest << "#---------- SOLID: " << pv_name << "\n";
    190 
    191     if ( IsPVPickable() ) {
    192 
    193      fDest << "Anchor {" << "\n";
    194      fDest << " description " << "\"" << pv_name << "\"" << "\n";
    195      fDest << " url \"\" " << "\n";
    196      fDest << " children [" << "\n";
    197     }
    198 
    199     fDest << "\t"; fDest << "Shape {" << "\n";
    200 
    201     SendMaterialNode();
    202 
    203     fDest << "\t\t" << "geometry IndexedFaceSet {" << "\n";
    204 
    205     fDest << "\t\t\t"   << "coord Coordinate {" << "\n";
    206     fDest << "\t\t\t\t" <<      "point [" << "\n";
    207     G4int i, j;
    208     for (i = 1, j = polyhedron.GetNoVertices(); j; j--, i++) {
    209         G4Point3D point = polyhedron.GetVertex(i);
    210 
    211         point.transform( *fpObjectTransformation );
    212 
    213         fDest << "\t\t\t\t\t";
    214         fDest <<                   point.x() << " ";
    215         fDest <<                   point.y() << " ";
    216         fDest <<                   point.z() << "," << "\n";
    217     }
    218     fDest << "\t\t\t\t" <<      "]" << "\n"; // point
    219     fDest << "\t\t\t"   << "}"      << "\n"; // coord
    220 
    221     fDest << "\t\t\t"   << "coordIndex [" << "\n";
    222 
    223     // facet loop
    224     G4int f;
    225     for (f = polyhedron.GetNoFacets(); f; f--) {
    226 
    227         // edge loop
    228         G4bool notLastEdge;
    229         G4int index = -1, edgeFlag = 1;
    230         fDest << "\t\t\t\t";
    231         do {
    232             notLastEdge = polyhedron.GetNextVertexIndex(index, edgeFlag);
    233             fDest << index - 1 << ", ";
    234         } while (notLastEdge);
    235         fDest << "-1," << "\n";
    236     }
    237     fDest << "\t\t\t"   << "]" << "\n"; // coordIndex
    238 
    239     fDest << "\t\t\t"   << "solid FALSE" << "\n"; // draw backfaces
    240 
    241     fDest << "\t\t" << "}"     << "\n"; // IndexFaceSet
    242     fDest << "\t" << "}"       << "\n"; // Shape
    243 
    244     if ( IsPVPickable() ) {
    245      fDest << " ]"              << "\n"; // children
    246      fDest << "}"               << "\n"; // Anchor
    247     }
    248 
    249 }




vrml2file driver 
-----------------


::


    [blyth@cms01 src]$ l G4VRML2*
    -rw-r--r--  1 blyth blyth  2954 Mar 16  2009 G4VRML2.cc
    -rw-r--r--  1 blyth blyth  2588 Mar 16  2009 G4VRML2File.cc
    -rw-r--r--  1 blyth blyth  7184 Mar 16  2009 G4VRML2FileSceneHandler.cc
    -rw-r--r--  1 blyth blyth  4932 Mar 16  2009 G4VRML2FileViewer.cc
    -rw-r--r--  1 blyth blyth  4407 Mar 16  2009 G4VRML2SceneHandler.cc
    -rw-r--r--  1 blyth blyth 18480 Mar 16  2009 G4VRML2SceneHandlerFunc.icc
    -rw-r--r--  1 blyth blyth  4651 Mar 16  2009 G4VRML2Viewer.cc
    [blyth@cms01 src]$ 
    [blyth@cms01 src]$ pwd
    /data/env/local/dyb/trunk/external/build/LCG/geant4.9.2.p01/source/visualization/VRML/src

    [blyth@cms01 src]$ grep icc G4VRML2*.cc
    G4VRML2FileSceneHandler.cc:#include "G4VRML2SceneHandlerFunc.icc"
    G4VRML2SceneHandler.cc:#include "G4VRML2SceneHandlerFunc.icc"


Common 



source/visualization/VRML/include/G4VRML2FileSceneHandler.hh
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

From Geant4 solid instances into the scene rep.::

     46 class G4VRML2FileSceneHandler: public G4VSceneHandler {
     47 
     48   friend class G4VRML2FileViewer;
     49 
     50 // methods (public) 
     51 public:
     52     G4VRML2FileSceneHandler(G4VRML2File& system, const G4String& name = "");
     53     virtual ~G4VRML2FileSceneHandler();
     54     void AddSolid(const G4Box&);
     55     void AddSolid(const G4Cons&);
     56     void AddSolid(const G4Tubs&);

Pickability, what does that mean for VRML2 ?::

    103     // PV name pickability  
    104     if( getenv( "G4VRML_PV_PICKABLE" ) != NULL ) {
    105 
    106         int is_pickable ;
    107         sscanf( getenv("G4VRML_PV_PICKABLE"), "%d", &is_pickable ) ;
    108 
    109         if ( is_pickable ) { SetPVPickability ( true ) ; }
    110     }
    111 
    112     // PV Transparency
    113     SetPVTransparency ();

Defer to common code for decomposition into primitives::

    111 void G4VRML2SCENEHANDLER::AddSolid(const G4Sphere& sphere)
    112 {
    113 #if defined DEBUG_SCENE_FUNC
    114     G4cerr << "***** AddSolid sphere" << "\n" ;
    115 #endif
    116     VRMLBeginModeling () ;
    117     G4VSceneHandler::AddSolid(sphere) ;
    118 }

Preprocessor icc trick to avoid duplication::

    127 #define  G4VRML2SCENEHANDLER   G4VRML2FileSceneHandler
    128 #define  IS_CONNECTED   this->isConnected() 
    129 #include "G4VRML2SceneHandlerFunc.icc"
    130 #undef   IS_CONNECTED
    131 #undef   G4VRML2SCENEHANDLER


The header.

::

    498 void G4VRML2SCENEHANDLER::VRMLBeginModeling()
    499 {
    500     if (!IS_CONNECTED ) {
    501 #if defined DEBUG_SCENE_FUNC
    502     G4cerr << "***** VRMLBeginModeling (started)" << "\n" ;
    503 #endif
    504         this->connectPort();
    505         fDest << "#VRML V2.0 utf8" << "\n";
    506         fDest << "# Generated by VRML 2.0 driver of GEANT4\n" << "\n";
    507     }
    508 }




source/visualization/VRML/include/G4VRML2SceneHandler.hh
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hmm, looks to duplicate much of `G4VRML2FileSceneHandler.hh`. Presumably just different
destinations, live graphics OR file.

::

     49 class G4VRML2SceneHandler: public G4VSceneHandler {
     50 
     51     enum { MAX_CONNECTION_TRIAL = 10 } ;
     52 
     53 // methods (public) 
     54 public:
     55     G4VRML2SceneHandler(G4VRML2& system, const G4String& name = "");
     56     virtual ~G4VRML2SceneHandler();
     57     void AddSolid(const G4Box&);
     58     void AddSolid(const G4Cons&);
     59     void AddSolid(const G4Tubs&);


::

    [blyth@cms01 include]$ diff G4VRML2FileSceneHandler.hh G4VRML2SceneHandler.hh
    27c27
    < // $Id: G4VRML2FileSceneHandler.hh,v 1.16 2006/06/29 21:25:39 gunter Exp $
    ---
    > // $Id: G4VRML2SceneHandler.hh,v 1.13 2006/06/29 21:25:43 gunter Exp $
    30c30
    < // G4VRML2FileSceneHandler.hh
    ---
    > // G4VRML2SceneHandler.hh

    ...
    98c101
    <       void connectPort();
    ---
    >       void connectPort(int max_trial = MAX_CONNECTION_TRIAL );
    ...
    140c135
    <       std::ofstream     fDest ;
    ---
    >       G4FRClient fDest ;



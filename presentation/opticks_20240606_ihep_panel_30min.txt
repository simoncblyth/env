.. meta::
   :title: Simon C Blyth : IHEP Institute Introduction Report
   :description: (2024 June 6) JUNO, OptiX, Opticks
   :note0: 30 min 
   :url: https://indico.ihep.ac.cn/event/22301/

.. include:: my_s5defs.txt


.. comment

   * 2  min : personal profile 
   * 14 min : past work achievements (personal role must be mentioned)  
   * 6 min  : future scientific research plans  
   * 3 min  : required support conditions (funding, personnel)  
   * 25 min : TOTAL

   TO COVER

   * US GPU restriction
   * plans
   * required support

   The content mainly includes 

   * personal profile, 
   * past work achievements (personal role must be mentioned), 
   * future scientific research plans, 
   * and required support conditions (funding, personnel).


.. comment

    <i>Opticks</i> : GPU Optical Photon Simulation</br> via NVIDIA OptiX 7, NVIDIA CUDA

    NVIDIA® OptiX™


:i:`Simon C. Blyth : IHEP Institute Introduction Report`
==========================================================================================

.. raw:: html

    <div class="mytitle">
    <header>
    <h1 style="background-color:lightgrey;text-align:center;"> 
        <i>Simon C. Blyth</i> : IHEP Institute Introduction Report 
        <h2 style="background-color:lightgrey;text-align:center">
            Open source, https://bitbucket.org/simoncblyth/opticks 
        </h2>
    </h1>
    </header>
    </div>
    <!--img style="position:absolute; top:200px; LEFT:100px; WIDTH:200px; " src="juno/JUNO_logo.png"  /-->
    <div class="mycredit">
       <h2 style="background-color:lightgrey">
          Simon C Blyth, IHEP, CAS &mdash; IHEP Institute Introduction Report &mdash; 6 June 2024
       </h2>
    </div>

.. s5_talk:: 

    Opticks is an open source project that applies GPU ray tracing to optical photon simulation 
    and integrates this with Geant4. This can give drastic speedups of more than a factor of 1000.
    This approach removes memory and processing bottlenecks that can prevent the 
    optical photons from limiting simulations.  

    The actual speedup depends on your geometry and your effort in avoiding 
    geometry issues. 

    This render shows the photons resulting from a muon crossing the JUNO scintillator, 
    each line represents a single photon.


Outline
--------------

.. comment 

    Title marker needs to be long for rst2rst.py matching  

    * Achievements Summary
    * NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing

.. image:: /env/presentation/newtons-opticks.png 
   :width: 299px
   :height: 547px 
   :align: right


.. class:: small

    * Dr Simon C. Blyth (D.Phil) : Personal Profile
    * Primary Research Goal
    * Secondary Research Goal
    * Context and Principal of Opticks

      * Optical Photon Simulation Problem...
      * Optical Photon Simulation ≈ Ray Traced Image Rendering
      * NVIDIA Ada : 3rd Generation RTX
      * Geant4 + Opticks + NVIDIA OptiX : Hybrid Workflow
      * Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 

    * HEP Community+NVIDIA Interest/Help with Opticks 

      * Optical photons limit many simulations => lots of interest in Opticks
      * CHEP 2019 Plenary, Adelaide, Australia
      * 2020 : Leap in Opticks Awareness : Meetings, Publications >>> New Users
      * LHCb RICH + Opticks
      * LZ+Opticks : contacts with >5 LZ people
      * Integration of Opticks and Geant4
      * NVIDIA Giveth and NVIDIA Taketh away ...
      * Assistance : Geant4 Collab. + Dark Matter Search Community + NVIDIA


.. s5_talk::

   After a brief introduction I will cover:

   * integration of Opticks with Geant4, 
   * its increasingly widespread usage
   * progress on integration of Opticks with JUNO Offline 
   * and the next steps.





Dr Simon C. Blyth (D.Phil) : Personal Profile 
----------------------------------------------------------

:r:`Early focus on analysis "fruit picking" in DELPHI, L3 and BELLE`  

.. class:: small

   1990/10 - 1994/11 : *D.Phil Research with Oxford DELPHI group, based at Oxford and CERN*
     Measurement of Radiative muon pair cross-sections and asymmetries below Z pole and ZPrime limits 

   1995/06 - 2002/02 : *RA with Carnegie Mellon L3 group, based at CERN*
     * On site management of L3 luminosity detector group and luminosity analysis 
     * Best L3 Measurement of the forward-backward asymmetry of b quarks
 
   2002/08 - 2006/08 : *Researcher based at NTU Taiwan* 
     BELLE : Measurements of B0 -> D(*)0h0, where h0 is pi0, eta or omega (36 final states)

.. raw:: html

   <hr/>

.. class:: small

   2006/08 - 2013/07 : *Researcher with National United University, Taiwan based at NTU* 
     Central role in design, implementation and operation of Daya Bay infrastructure:
 
     * Managed setup and customization of Trac/Subversion webapp at IHEP 
     * Managed Daya Bay Offline Database since July 2010 + 
     * Developed software testing framework and distributed build/test system 
     * Developed Python interface to Daya Bay C++ Database Framework

.. s5_talk::

    As a student and in my first few positions my focus
    was on picking the fruits of analysis from DELPHI, L3 and BELLE expts.
    Later on I transitioned from fruit picking to growing the tree of Daya Bay 
    and JUNO in software and I particularly like that my work on Opticks 
    can help many experiments.  

    * going by way of the tasks that needed to be done 
    * difficult to know for sure, but I hope my achievements with Opticks 
      providing some motivation to make more use of GPUs in HEP software


Dr Simon C. Blyth (D.Phil) : Personal Profile 
-----------------------------------------------

:r:`Transitioned from "fruit picking" to "growing trees"` 
   :r:`of Daya Bay, JUNO + ... (the many expts of Opticks users)`  

.. class:: small 

   2013/08 - 2017/12 : *Researcher with National Taiwan University, Taipei based at NTU*
     Original research and development of GPU optical photon simulation framework, Opticks, 
     yielding unprecedented optical photon propagation performance.

   2018/05-11, 2019/03-12, 2020/04-12 : *Visiting Scientist, CAS Presidents International Fellowship Initiative* 
     * Generalizing Opticks to enable integration with JUNO simulation.
     * Enabled fully automated geometry management, via direct geometry translation.
     * Created Geant4 Advanced Example, included in Geant4 distribution
 
   2021/02-2024/02 : *Senior Project Scientist JUNO, Visiting Researcher of IHEP* 
     Bringing Opticks into Production usage within JUNO simulation.

     * Original development of shared GPU/CPU optimized CSG geometry model 
     * Enable state-of-the-art NVIDIA OptiX ray tracing of auto-translated detector geometry
     * Detailed JUNO+Opticks validations reveal steady stream of geometry and physics issues
 
       * fixed many issues, including unphysical PMT Optical Model 



Primary Research Goal 
----------------------

.. raw:: html

     <p style="margin-bottom:0.5cm;" />

.. class:: normal

    ..

        Maximize Opticks benefits to JUNO (and beyond) 
        from unprecedented leap in optical photon simulation speed
        and offloading memory demands to GPU 


.. raw:: html

     <p style="margin-bottom:-0.5cm;" />

.. class:: normal
        
    * :b:`simulation unlimited by optical photons => greater understanding => more fruit` 
       
      * :r:`JUNO: optimum muon veto => maximum livetime => maximum impact`



:small:`Steps to Maximize Opticks benefits to JUNO (and beyond)`
-----------------------------------------------------------------



.. sidebar:: :small:`Longterm Opticks`  

    .. class:: small

        * try non-NVIDIA GPUs + ray tracing backends
        * foster community of Opticks users/developers (neutrino, DM search, medical)

          * assist users with geometry optimization
          * video meetings, side workshops at CHEP

        **Seamless integration with Geant4**

        * develop+propose Geant4 external optical API 
        * Opticks as optional Geant4 external 
        * Opticks interactive+precise ray trace rendering  
        

.. sidebar:: :small:`Outreach: Event viewers`  

    .. class:: small

         * WebGL : browser viewer (no install)
         * AR/VR headset : immersive experience 






.. class:: small

    **Feature completion**

    * full test of "listnode" solution to complex geometry issue
    * automated continuous integration/validation 

    **Publications**

    * "JUNO use of Opticks GPU optical photon simulation"
    * "Opticks GPU optical photon simulation" (impl. details)

    **Performance optimization**

    * auto split/join event depending on GPU VRAM
    * extend Opticks to concurrently launch on multiple GPUs
    * try alternative CSG tree serialization + CSG intersection
    * try iterative intersection (eg sphere tracing using generation
      of CUDA code for pure signed distance functions (SDF)) 

    **JUNOSW+Opticks MC Production optimization**

    * Tune config for local GPU cluster running  
    * Enable distributed productions 
  



.. comment

    .. image:: nvidia/H20_L20_L2/tomshardware_h20_l20_l2_spec.png
       :width: 624px
       :height: 764px 
       :align: right

    https://www.techpowerup.com/gpu-specs/l20.c4206




NVIDIA GPUs for China
------------------------


Secondary Research Goal 
-------------------------

.. raw:: html

     <p style="margin-bottom:0.5cm;" />

.. class:: normal

     ..

        Maximize GPU benefits to HEP projects able to innovate, such as CEPC 

.. raw:: html

     <p style="margin-bottom:-0.5cm;" />


.. class:: normal

     * :b:`HEP transition to massively parallel future with GPUs`

       * :r:`change needed everywhere: data structures, computation, processing` 
         
         * :r:`huge opportunity for innovators to impact field` 


.. s5_talk::

   * :b:`Need to re-imagine the whole branches of the "tree" of future expt`








.. comment

    Achievements Summary
    ---------------------

    .. class:: small

        **Conceived and developed "Opticks" : an innovative solution to the "Optical Photon Simulation Problem"**
     
        * state-of-the-art GPU ray tracing applied to optical photon simulation
        * auto-translation of Geant4 geometry to GPU optimized form    
        * avoids optical photons from limiting simulations
        * unprecedented optical photon simulation speed : > 1000x faster than serial processing
        * also offloads large memory demands to the GPU   
        * Opticks example included with Geant4 distribution
        * Opticks is used by multiple experiments, many more dark matter search + neutrino expts interested


    .. raw:: html

        <hr/>

    .. class:: small

        **Daya Bay offline infrastructure : DB manager+interface, Trac/SVN Webapp, unittest**

        **Management : L3 Luminosity group onsite manager**

        **Data Analysis at LEP, LEP1.5, LEP2 and KEKB B-factory**  

        * BELLE : Branching Fraction measurements : B0 -> D(*)0h0 , where h0 is pi0, eta or omega (36 final states)
        * LEP heavy flavor working group combinations  
        * L3 : Luminosity, Most precise L3 determination of the b quark asymmetry
        * DELPHI : Radiative muon pair cross-sections and asymmetries below Z pole and Z limits


    .. s5_talk::

        I started out with analysis and transitioned to software development

        * going by way of the tasks that needed to be done 
        * difficult to know for sure, but I hope my achievements with Opticks 
          providing some motivation to make more use of GPUs in HEP software




.. comment

    * Rasterization vs Ray-tracing
    * Spatial Index Acceleration Structure
    * NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing
    * Ray intersection with general CSG binary trees, on GPU


Context and Principal of Opticks
----------------------------------


.. raw:: html

     <p style="margin-bottom:3cm;" />


* Optical Photon Simulation Problem...
* Optical Photon Simulation ≈ Ray Traced Image Rendering
* NVIDIA Ada : 3rd Generation RTX
* Geant4 + Opticks + NVIDIA OptiX Hybrid Workflow
* Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 


`JUNO Optical Photon Simulation Problem...`
---------------------------------------------------------

.. raw:: html

     <p style="margin-bottom:7cm;" />

.. sidebar:: :small:`Huge CPU Memory+Time Expense`

    .. class:: small

         **JUNO Muon Simulation Bottleneck**
           ~99% CPU time, memory constraints

         **Ray-Geometry intersection Dominates**
           simulation is not alone in this problem...

         **Optical photons : naturally parallel, simple :**
           * produced by Cherenkov+Scintillation 
           * yield only Photomultiplier hits


.. s5_talk::

   So, what is the problem with optical photon simulation ? 

   A muon travelling across the JUNO scintillator yields tens of millions 
   of optical photons, presenting memory and time challenges. 

   At every step of every photon intersects between rays representing the 
   photons and the geometry have to be found.  This is what limits the simulation. 

   Simulation is not alone in this bottleneck.


.. comment

   Optical photons are naturally parallel : they can be considered 
   to be produced only by two processes : Cherenkov and Scintillation and we
   are interested in photons that hit the PMTs.  

   These characteristics make it straightforward integrate an external optical
   simulation.
 



:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering`
-------------------------------------------------------------------------------

.. sidebar:: :small:`Not a Photo, a Calculation`

    .. image:: ../optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    :b:`simulation` 
       photon parameters at sensors (PMTs) 

    :b:`rendering` 
       pixel values at image plane


.. raw:: html

    <p style="margin-bottom:2cm;" />


.. class:: small

    **Much in common : geometry, light sources, optical physics**

    * :redbold:`both limited by ray geometry intersection, aka ray tracing`

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    **Many Applications of ray tracing** :

    * advertising, design, architecture, films, games,...
    * -> huge efforts to improve hw+sw over 30 yrs


.. s5_talk::

    So, how can GPU ray tracing help with simulation. 

    There is a lot in common between optical photon simulation and ray traced image rendering.   
    Simulation needs photon parameters at sensors, rendering needs pixel values at the image plane.

    Both these are limited by ray geometry intersection, which is also known as ray tracing.

    Ray tracing is widely used across many industries from advertising to games, so 
    there has been huge efforts to improve ray tracing performance, especially from NVIDIA. 
    


.. comment

    :i:`Rasterization vs Ray-tracing`
    -----------------------------------

    .. image:: nvidia/nv_rasterization.png
       :width: 550px
       :align: left

    .. image:: nvidia/nv_raytrace.png
       :width: 550px
       :align: right


    .. s5_talk::

       Ray tracing and rasterization are the two primary graphics rendering techniques. 

       Rasterization is the most common rendering technique
       
       * it starts from the objects in a scene, and projects them onto pixels in the image plane
       * this requires an approximate triangulated geometry, to have vertices to project 
       
       Ray tracing 

       * starts from the pixels, casts rays out into the 3D scene and finds intersects
       * this can use analytic geometry, without approximation (just like Geant4)   
       * its easier to create realistic images with ray tracing because it is closer to the physics

       Ray tracing is an overloaded term.  In some contexts it means just the ray transport
       from an origin to an intersection. But is also refers more generally to the rendering technique. 

    .. comment

       https://www.youtube.com/watch?v=Mrixi27G9yM
       RTX Launch


    ``Spatial Index Acceleration Structure``
    ---------------------------------------------------

    .. raw:: html

        <p style="margin-bottom:11cm;" />

    .. sidebar:: :small:`Tree of Bounding Boxes (bbox)`

        .. class:: small

            * aims to minimize bbox+primitive intersects 
            * accelerates ray-geometry intersection


    .. s5_talk::

       The principal technique to accelerate ray geometry intersection 
       is an acceleration structure called a bounding volume hierarchy 
       
       This divides space into progressively smaller boxes which forms
       a spatial index.

       Traversing the tree of bounds allows to minimize tests
       needed to find an intersect.

       Much of the acceleration structure traversal 
       is done in the dedicated RT cores.



:small:`NVIDIA Ada : 3rd Generation RTX`
--------------------------------------------------------------------------

.. class:: small

   * **RT Core** : ray trace dedicated GPU hardware

   * **NVIDIA GeForce RTX 4090 (2022)** 

     * 16,384 CUDA Cores, 24GB VRAM, USD 1599

   * :r:`Continued large ray tracing improvements:` 

     * **Ada** ~2x ray trace over **Ampere** (2020), 4x with DLSS 3
     * **Ampere** ~2x ray trace over **Turing** (2018)  
    
   * DLSS : Deep Learning Super Sampling 

     * AI upsampling, not applicable to optical simulation



.. s5_talk::

    GPU Ray Tracing performance continues to improve rapidly.
    There has been roughly doubling in raw ray tracing performance
    with each generation of NVIDIA RTX GPUs. 

    [Notes to Presenter]
    [<20s slide : No need to read the slide, just say the above comment]    



.. comment

    :small:`NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing`
    --------------------------------------------------------------------------

    .. sidebar:: :small:`Flexible Ray Tracing Pipeline` 

        .. class:: small

            :g:`Green: User Programs`,  :e:`Grey: Fixed function/HW`

        .. image:: nvidia/optix7/OptiX-API.png
           :width: 450px
           :align: right

        .. class:: small

            :b:`Analogous to OpenGL rasterization pipeline` 


    .. class:: small

       **OptiX makes GPU ray tracing accessible**

       * :r:`Programmable GPU-accelerated Ray-Tracing Pipeline`
       * Single-ray shader programming model using CUDA
       * ray tracing acceleration using RT Cores (RTX GPUs)
       * "...free to use within any application..."

       **OptiX features**

       * acceleration structure creation + traversal (eg BVH)
       * instanced sharing of geometry + acceleration structures
       * compiler optimized for GPU ray tracing

    .. class:: tiny

       ``https://developer.nvidia.com/rtx/ray-tracing/optix``

    .. class:: small

       **User provides (Green):**

       * ray generation
       * geometry bounding boxes
       * intersect functions 
       * instance transforms

       :r:`Same high level model in OptiX 7, everything else new` 
       

    .. s5_talk::

       While all details changed in the giant leap from OptiX 6=>7 
       the high level structure mostly remained.  

       NVIDIA OptiX makes GPU ray tracing accessible 

       * it divides up the ray tracing workflow 
       * the green boxes represent user provided CUDA programs, including:

         * ray generation : where Opticks generates photons and steers the simulation
         * intersection : where the CSG geometry is implemented 

       * geometry has to be translated into a GPU appropriate easily serialized form





Geant4 + Opticks + NVIDIA OptiX : Hybrid Workflow
-------------------------------------------------------------

.. class:: small

    .. table::
        :align: center

        +--------------------------------------------------+
        | :b:`https://bitbucket.org/simoncblyth/opticks`   |
        +--------------------------------------------------+


.. raw:: html

    <p style="margin-bottom:13cm;" />

.. class:: small

    Opticks API : split according to dependency -- Optical photons are GPU "resident", only hits need to be copied to CPU memory 


.. s5_talk::

    This shows how Opticks is integrated with Geant4. The geometry is translated 
    and uploaded to the GPU at initialization.

    Cerenkov or Scintillation gensteps, the blue lines, are the generation parameters 
    uploaded to the GPU so optical photon generation can be done there.

    This allows the optical photon simulation to be entirely offloaded  
    to the GPU with only collected hits requiring memory on the CPU.
 


Principal Achievements of Opticks
----------------------------------

* CUDA constructive solid geometry (CSG) intersect implementation 
* innovative CSGFoundry CPU/GPU geometry model 
* auto-translation of Geant4 geometry to CSGFoundry model :b:`without approximation`

  * can almost exactly match Geant4 intersects on GPU

* unprecedented optical photon simulation speed : > 1000x faster than serial processing
* offloads large memory demands to the GPU   
 

 
.. comment

    :small:`Ray intersection with general CSG binary trees, on GPU`
    ---------------------------------------------------------------------------------

    .. sidebar:: Outside/Inside Unions

        .. class:: small

           dot(normal,rayDir) -> Enter/Exit

        .. image:: kensler_union_of_two_spheres_from_outside.png
           :width: 300px
           :align: center

        .. image:: kensler_union_of_two_spheres_from_inside.png
           :width: 300px
           :align: center

        .. class:: small

            * **A + B** boundary not inside other 
            * **A * B** boundary inside other 


    .. class:: small

       Pick between pairs of nearest intersects, eg:

       =======================  ===========  ===============  ============== 
       *UNION* tA < tB           Enter B      Exit B           Miss B
       =======================  ===========  ===============  ============== 
       **Enter A**               ReturnA      :blue:`LoopA`    ReturnA
       **Exit A**                ReturnA      ReturnB          ReturnA 
       **Miss A**                ReturnB      ReturnB          ReturnMiss
       =======================  ===========  ===============  ============== 

       * *Nearest hit intersect algorithm* [1] avoids state

         * sometimes :blue:`Loop` : advance **t_min** , re-intersect both 
         * classification shows if inside/outside

       * *Evaluative* [2] implementation emulates recursion: 

         * :red:`recursion not allowed` in OptiX intersect programs
         * bit twiddle traversal of complete binary tree 
         * stacks of postorder slices and intersects 

       * :red:`Identical geometry to Geant4` 

         * solving the same polynomials 
         * near perfect intersection match



    .. class:: tiny

        [1] Ray Tracing CSG Objects Using Single Hit Intersections, Andrew Kensler (2006)
            with corrections by author of XRT Raytracer http://xrt.wikidot.com/doc:csg
     
        [2] https://bitbucket.org/simoncblyth/opticks/src/tip/optixrap/cu/csg_intersect_boolean.h
            Similar to binary expression tree evaluation using postorder traverse. 


    .. s5_talk::

       The Algorithm reduces the problem to a choice between intersects
       that is applied recursively to the tree of nodes that represents the shape. 





:small:`Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7`
-------------------------------------------------------------------------------

.. sidebar:: :small:`CSGFoundry Model`

    .. class:: small

        * :b:`array-based -> simple serialization + upload`
        * entire geometry in 4 GPU allocations 
        * factorized using subtree digests 

.. class:: small

    **Geant4 Geometry Model (JUNO: 300k PV, deep hierarchy)**

    +----+---------------------------+---------------------------------------------+ 
    | PV | *G4VPhysicalVolume*       | placed, refs LV                             |
    +----+---------------------------+---------------------------------------------+ 
    | LV | *G4LogicalVolume*         | unplaced, refs SO                           |
    +----+---------------------------+---------------------------------------------+ 
    | SO | *G4VSolid,G4BooleanSolid* | binary tree of SO "nodes"                   |
    +----+---------------------------+---------------------------------------------+ 

    **Opticks CSGFoundry Geometry Model** (index references)

    +---------------+----------------------------------------------------------------------------+----------------------------+
    | struct        | Notes                                                                      |  Geant4 Equivalent         |
    +===============+============================================================================+============================+
    | *CSGFoundry*  | vectors of the below, easily serialized + uploaded + :r:`used on GPU`      | None                       |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *qat4*        | 4x4 transform refs *CSGSolid* using "spare" 4th column (:b:`becomes IAS`)  | Transforms ref from PV     |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGSolid*    | refs sequence of *CSGPrim*                                                 | Grouped Vols + Remainder   | 
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGPrim*     | bbox, refs sequence of *CSGNode*, root of CSG Tree of nodes                | root *G4VSolid*            |
    +---------------+----------------------------------------------------------------------------+----------------------------+
    | *CSGNode*     | CSG node parameters (JUNO: ~23k *CSGNode*)                                 | node *G4VSolid*            |
    +---------------+----------------------------------------------------------------------------+----------------------------+

    **NVIDIA OptiX 7 Geometry Acceleration Structures (JUNO: 1 IAS + 10 GAS, 2-level hierarchy)**

    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | IAS | Instance Acceleration Structures | JUNO: 1 IAS created from vector of ~50k *qat4* (JUNO)                   |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | GAS | Geometry Acceleration Structures | JUNO: 10 GAS created from 10 *CSGSolid* (which refs *CSGPrim,CSGNode* ) |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 

.. class:: small

    :r:`JUNO : Geant4 ~300k volumes "factorized" into 1 OptiX IAS referencing ~10 GAS`


.. s5_talk::

   The tables illustrates three geometry models.

   The CSGFoundry geometry model in the middle was designed 
   to enable translation between the Geant4 and OptiX models. 




:i:`cxr_overview_emm_t0_elv_t_moi__ALL_with-debug-disable-xj.jpg`
------------------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:2cm;" />


.. sidebar:: :small:`JUNO Opticks OptiX 7 Ray-trace`

    .. class:: small

        * :redbold:`purely analytic CSG, no triangles` 
      
        +--------------------------------------------+
        |  raytrace 2M pixels 1920x1080              |
        +======================+=====================+
        | **NVIDIA TITAN RTX** | 0.0091s (~110 FPS)  |
        | (1st gen. RT Cores)  |                     |
        +----------------------+---------------------+


.. s5_talk::

   Here is a ray trace render of JUNO using OptiX 7 
   There are no triangles here, this is a purely analytic ray trace with 
   the exact same geometry that the simulation uses.

       [Notes: ~10s slide, just the comment] 




:i:`Opticks Analytic Daya Bay Near Site, GPU Raytrace`
--------------------------------------------------------

.. raw:: html

    <p style="margin-bottom:8cm;" />


.. class:: small

    ``Pure analytic CSG Daya Bay near geometry, auto-converted from Geant4 to Opticks GPU geometry, 
    NVIDIA OptiX GPU raytrace render [no triangles]``


.. s5_talk::

   Using that GPU CSG algorithm enabled : pure analytic ray trace-ing.  So that means the 
   geometry is not approximate any more, it can match Geant4 intersects very closely. 
   Its because the two implementations are solving the same polynomials. 



.. comment

    :i:`j1808_top_rtx`
    --------------------

    .. class:: small

        ``Pure analytic CSG JUNO geometry, auto-converted from Geant4 to Opticks GPU geometry, 
        NVIDIA OptiX GPU raytrace render [no triangles] (GGeoView)``


    .. s5_talk::

       The upshot is that full Geant4 detector geometries
       can be automatically translated into NVIDIA OptiX geometries.

       This is an OptiX ray trace image from the chimney region at the 
       top of the JUNO scintillator sphere.
        

.. comment

    :i:`j1808_top_ogl`
    --------------------


    .. class:: small

        ``Approximate triangulated JUNO geometry [note impingement of torus guide tube and acrylic "sphere"], OpenGL rasterized render (GGeoView)``


    .. s5_talk::

       This is an OpenGL rasterized image, using the approximate triangulated 
       geometry. Opticks manages analytic and triangulated geometry together.  





.. comment

    :small:`NVIDIA OptiX 7 : Entirely new thin API => Full Opticks Re-implementation`
    -----------------------------------------------------------------------------------

    .. sidebar:: :small:`GPU Ray Tracing APIs Converged`

        .. class:: small

            * 3 APIs (DXR,VKRay,OptiX7) over RTX 
            * Driver updates :r:`independent of application`  
            * Support new GPUs, performance improvements 

    .. class:: small

        **NVIDIA OptiX 6->7** : :b:`drastically slimmed down`

        * low-level CUDA-centric thin API (Vulkan-ized)
        * headers only (no library, impl in Driver) 
        * Minimal host state,  :red:`All host functions are thread-safe`
        * GPU launches : explicit, asynchronous (CUDA streams)
        * :strike:`near perfect scaling to 4 GPUs, for free` 
        * :strike:`Shared CPU/GPU geometry context` 

          * :r:`=> NEED CPU/GPU GEOMETRY MODEL + TRANSLATOR`

        * :strike:`GPU memory management`
        * :strike:`Multi-GPU support`


    .. class:: small

        **Advantages of 6->7 transition**

        * More control/flexibility over everything 
        * :b:`Keep pace with state-of-the-art GPU ray tracing` 
        * Fully benefit from current + future GPUs : RT cores, RTX 

    .. class:: small

        **BUT:** :r:`demanded full re-implementation of Opticks` 
         


    .. s5_talk::

       * OptiX 7 is an entirely new API, dropping many features used by the old Opticks
       * re-implementation of almost all of Opticks was necessary

       [Notes: No need to read slide, just the above comments]




.. comment

    :small:`Opticks : Translate Geant4 Optical Physics to GPU (OptiX/CUDA)`
    --------------------------------------------------------------------------

    .. sidebar:: :small:`GPU Resident Photons`

        .. class:: small

           **Seeded on GPU** 
              associate photons -> *gensteps* (via seed buffer)
     
           **Generated on GPU, using genstep param:**
             * number of photons to generate
             * start/end position of step
             * *gensteps* : hybrid CPU+GPU generation

           **Propagated on GPU**
              :red:`Only photons hitting PMTs copied to CPU`


           Thrust: **high level C++ access to CUDA**

           .. figure:: /env/numerics/thrust/thrust.png
              :width: 300px
              :align: right

           * https://developer.nvidia.com/Thrust
           
                      
    .. class:: small

        :blue:`OptiX : single-ray programming model` -> line-by-line translation

        **CUDA Ports of Geant4 classes**
          * G4Cerenkov (only generation loop) 
          * G4Scintillation (only generation loop) 
          * G4OpAbsorption
          * G4OpRayleigh 
          * G4OpBoundaryProcess (only a few surface types)

        **Modify Cerenkov + Scintillation Processes**
          * collect *genstep*, copy to GPU for generation
          * :red:`avoids copying millions of photons to GPU`

        **Scintillator Reemission**
          * fraction of bulk absorbed "reborn" within same thread
          * wavelength generated by reemission texture lookup

        **Opticks (OptiX/Thrust GPU interoperation)** 
          * **OptiX** : upload gensteps 
          * **Thrust** : seeding, distribute genstep indices to photons
          * **OptiX** : launch photon generation and propagation
          * **Thrust** : pullback photons that hit PMTs 
          * **Thrust** : index photon step sequences (optional)



    .. s5_talk::

        In addition to the geometry the optical physics is also needed on the GPU.

        * fortuntely it was straightforward to port the geant4 implementations to CUDA






HEP Community + NVIDIA Interest/Help with Opticks 
---------------------------------------------------


.. raw:: html

     <p style="margin-bottom:3cm;" />



* Optical photons limit many simulations => lots of interest in Opticks
* CHEP 2019 Plenary, Adelaide, Australia
* 2020 : Leap in Opticks Awareness : Meetings, Publications >>> New Users
* LHCb RICH + Opticks
* LZ+Opticks : contacts with >5 LZ people
* Integration of Opticks and Geant4
* NVIDIA Giveth and NVIDIA Taketh away ...
* Assistance : Geant4 Collab. + Dark Matter Search Community + NVIDIA


:small:`Optical photons limit many simulations => lots of interest in Opticks`
--------------------------------------------------------------------------------

.. class:: small

    +-----------+-----------------------------------------------------------------------------+
    | **EXPT**  | **Reactor neutrino**                                                        |  
    +-----------+-----------------------------------------------------------------------------+
    | Daya Bay  | neutrino oscillations                                                       |
    +-----------+-----------------------------------------------------------------------------+
    | JUNO      | mass heirarchy + oscillations  => :r:`NVIDIA CN Contacts`                   |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Long baseline neutrino beam**                                             |
    +-----------+-----------------------------------------------------------------------------+
    | DUNE      | FermiLab->Sanford, LAr TPC, => Assistance from :b:`Fermilab Geant4 Group`   |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Neutrinoless double beta decay, dark matter, other search**               |
    +-----------+-----------------------------------------------------------------------------+
    | LZ        | LUX-ZEPLIN dark matter experiment, Sandford  => :r:`NVIDIA US Contacts`     |
    +-----------+-----------------------------------------------------------------------------+
    | LEGEND    | Large Enriched Germanium Experiment, Gran Sasso/SNOLAB                      |
    +-----------+-----------------------------------------------------------------------------+
    | SABRE     | dark matter direct-detection, Australia                                     |
    +-----------+-----------------------------------------------------------------------------+
    | AMoRE     | Mo-based Rare process Experiment, S.Korea                                   |
    +-----------+-----------------------------------------------------------------------------+
    | nEXO      | next Enriched Xenon Observatory, LLNL                                       |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Neutrino telescope**                                                      |
    +-----------+-----------------------------------------------------------------------------+
    | KM3Net    | Cubic Kilometre Neutrino Telescope, Mediterranean                           |
    +-----------+-----------------------------------------------------------------------------+
    | IceCube   | IceCube Neutrino Observatory, South Pole                                    |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Air shower : gamma-ray and cosmic-ray observatory**                       |
    +-----------+-----------------------------------------------------------------------------+
    | LHAASO    | Large High Altitude Air Shower Observatory, Sichuan                         |
    +-----------+-----------------------------------------------------------------------------+
    |           | **Accelerator**                                                             |
    +-----------+-----------------------------------------------------------------------------+
    | LHCb-RICH | LHCb ring imaging Cherenkov sub-detector, CERN => :r:`NVIDIA EU Contacts`   |
    +-----------+-----------------------------------------------------------------------------+



.. s5_talk::

    Many simulations are limited by optical photons. 
    So, there is lots of interest in Opticks.
    Several groups has assisted with Opticks development 
    by using their contacts with NVIDIA 



``CHEP 2019 Plenary, Adelaide, Australia``
---------------------------------------------

.. s5_talk::

    This photo shows me presenting this at the CHEP plenary



:small:`2020 : Leap in Opticks Awareness : Meetings, Publications >>> New Users`
--------------------------------------------------------------------------------------

.. class:: small

   **(Feb 2020) Workshop on Efficient Computing for HEP, Edinburgh**

   * https://indico.ph.ed.ac.uk/event/66/ "Full Simulation of HEP Detectors with Geant4", Ben Morgan 

   **(May 2020) HSF (HEP Software Foundation) Meeting : GPUs in Simulations**

   * https://indico.cern.ch/event/921244/ "Opticks Development Experience : Problems and Successes", Simon Blyth

   **(10+24 June 2020) HSF Meeting : R&D on accelerators in Simulations** :red:`3/9 talks discussed Opticks`

   * https://indico.cern.ch/event/925887/ https://indico.cern.ch/event/930881/

   * "e/γ (GPU) calorimeter simulation.. ", John Apostolakis, "Prototyping simulation .. on GPUs", Andrei Gheata
     
   * "Prospects for (LHCb) RICH detector simulation using OptiX in GPUs", Sajan Easo

   **(Aug 2020) HSF Publication : HL-LHC Computing Review: Common Tools and Community Software**

   * https://zenodo.org/record/4009114 Graeme Stewart,... :red:`HL-LHC Computing Review discusses Opticks`

   **(Sep 2020) Geant4 : R&D Task Force Meeting** :red:`3+ Geant4 teams pursuing GPUs, 1 based on Opticks`    

   * https://indico.cern.ch/event/942142/sessions/363813/#20200915
        
   1. "G4Opticks for liquid Argon TPCs", Fermilab Geant4 Team, Hans Wenzel
   2. "VecGeom@GPU", CERN Geant4 Team, Andrei Gheata 


.. s5_talk::

   There has been quite a leap in Opticks awareness over the past year.

   * a few of the talks and publications discussing Opticks are listed here.
   * it is being actively evaluated by an increasing number of groups

   Why the leap ?

   * i guess my plenary presentation at the CHEP conference at the end of 2019 is the main cause
   * also using GPUs with Geant4 has become a hot topic over the past year, with 
     several high profile projects (Celeritas, AdePT) getting started 

    


:small:`2020 : Leap in Opticks Awareness >>> Some Users Getting Serious` 
-----------------------------------------------------------------------------------------

.. class:: small

   **(Aug 2020) Shanghai SJTU : Next-gen Neutrino Telescope Simulation Workshop**

   * https://indico-tdli.sjtu.edu.cn/event/238/sessions/109/#20200813 
   * "Opticks : GPU/Graphics backgroup + Application to underwater neutrino telescope simulations ?", Simon Blyth
   * :red:`SJTU team evaluating Opticks for deep ocean expt simulations (Fan Hu, Donglian Xu)`

   **(Aug 2020) Snowmass 2021 : Three LoI based on Opticks** : :red:`Multi-expt Dark Matter group invited me to sign LoI`   

   1. "Opticks : GPU photon simulation via NVIDIA OptiX", Simon Blyth
   2. "Fast simulations for Noble Liquid experiments", XENON, DARWIN, LZ teams, Simon Blyth
   3. "Simulating Optical Photons in HEP experiments on GPUs", Fermilab Geant4 team
 
   **(Aug 2020) NERSC Users Group (NUG) meeting** : :red:`LZ aiming to deploy Opticks on Perlmutter supercomputer`

   * https://www.nersc.gov/users/NUG/annual-meetings/nug-2020/ 
   * https://www.nersc.gov/assets/Uploads/1400-Opticks-on-CoriGPU.pdf 
   * "Opticks on CoriGPU", O.Creaner, 5 authors from : NERSC/LBL/LZ/Stanford/Bristol   
   * :red:`Opticks in Shifter/Docker container -> CoriGPU -> Perlmutter Cray/NVIDIA supercomputer`
   * Perlmutter : > 6000 NVIDIA A100 (Ampere Architecture GPU)  
 

.. class:: tiny 

   https://insidehpc.com/2020/05/perlmutter-supercomputer-to-include-more-than-6000-nvidia-a100-processors/


.. s5_talk::

   Several groups that have been evaluating Opticks for years are now starting to get serious.

   The LZ(LUX-Zepelin) dark matter experiment is the most advanced 
 
   * they aim to get Opticks going on the new Perlmutter supercomputer at NERSC 

    

.. comment

    :small:`G4OpticksTest : Demonstrates Geant4 + Opticks hybrid workflow`




:i:`lhcb_rich1_epjc_001.png`
-----------------------------
 

:small:`LZ with Opticks (Images from Sam Eriksen, University of Bristol)`
---------------------------------------------------------------------------


:small:`LZ+Opticks : contacts with >5 LZ people`
--------------------------------------------------------------------------------------------------

.. class:: small
 
   * :red:`Summer 2020 : LZ+Opticks simulation identified as candidate for new Perlmutter Cray/NVIDIA supercomputer at NERSC`
   * Autumn 2020 : LZ+NERSC proposed an NVIDIA assisted Hackathon to optimize LZ+Opticks simulation 

     * BUT no point optimizing prior to migration : NVIDIA OptiX 6 -> 7 (an entirely new "Vulkan-ized" API)  
     * migration to NVIDIA OptiX 7+ is unavoidable, it beings challenges and opportunities 

       * multi-GPU scaling no longer provided, thread-safe OptiX 7 opens possibilities, especially for Opticks Server+Client  

   **(Aug 2020) NERSC Users Group (NUG) meeting** : :red:`LZ aiming to deploy Opticks on Perlmutter supercomputer`

   * https://www.nersc.gov/users/NUG/annual-meetings/nug-2020/ 
   * "Opticks on CoriGPU", O.Creaner, 5 authors from : NERSC/LBL/LZ/Stanford/Bristol   


.. s5_talk::

   LZ has been evaluating Opticks over the past three years and it is now
   keep to scale up its usage to profit from the new NERSC Perlmutter supercomputer, 
   with more than 6000 NVIDIA A100 GPUs

   They proposed a Hackathon to optimize LZ+Opticks simulation.
   
   * but there is little point optimizing prior to migrating to the OptiX 7 API
   * after I pointed this out they indicated they could help with the migration







:small:`Integration of Opticks and Geant4`
------------------------------------------------------------------------

.. sidebar:: :small:`Plan for G4OpticksTest`

    .. class:: small

        * advanced example distributed with Geant4
        * explore use with G4Tasking with 10.7

.. class:: small

    **(Nov 2020) HSF WLCG Virtual Workshop : https://indico.cern.ch/event/941278/timetable/#20201123.detailed** 

    * Hans Wenzel, Fermilab Geant4 Team
    
    Worked closely with Hans for several years

    * Developed Geant4-Opticks integration API **G4Opticks**
    * Recently reported two Geant4 optical surface issues #2305 #2311 

.. s5_talk::

    The Fermilab Geant4 Team has been active for several years now with Opticks.

    * the inset slides are from Hans Wenzel 
    * my work with them has shaped the development of the G4Opticks interface.
    * also attempts to work with recent Geant4 releases have revealed some Geant4 optical bugs 





NVIDIA Giveth and NVIDIA Taketh away ...
------------------------------------------

.. class:: small 

   +------+------------------------------------------------------------------------------------------------------+
   | 2006 |  CUDA 1.0                                                                                            |
   +------+------------------------------------------------------------------------------------------------------+
   | 2009 |  NVIDIA OptiX 1.0                                                                                    |
   +------+------------------------------------------------------------------------------------------------------+
   | 2018 |  NVIDIA: "World's first ray tracing GPU" : ray trace dedicated RT cores, RTX, :b:`10 Giga Rays/s`    | 
   +------+------------------------------------------------------------------------------------------------------+
   | 2019 | Opticks: [1st Gen. RTX GPU] OptiX 6.5, JUNO analytic: 58s 400M photons (7M photons/s, ~70M rays/s)   | 
   +------+------------------------------------------------------------------------------------------------------+
   | 2019 |  NVIDIA OptiX 7.0 : **ENTIRELY NEW API**  :r:`=> Opticks needs full re-implementation`               | 
   +------+------------------------------------------------------------------------------------------------------+
   | 2021 |  NVIDIA Engineers assist Opticks dev. for 6->7 in series of seven meetings (LBNL, LZ )               | 
   +------+------------------------------------------------------------------------------------------------------+
   | 2022 |  3rd generation RTX : expect > 4x ray trace performance of 1st gen.                                  |   
   +------+------------------------------------------------------------------------------------------------------+

.. s5_talk::


    IN 2019 NVIDIA introduced an entirely new OptiX API, which effectively meant that Opticks
    had to be full re-implemented

    In 2018 NVIDIA introduced a GPU with hardware dedicated to accelerating ray tracing.
    NVIDIA claims it can reach 10 billion ray geometry intersections per second
    with a single GPU. 

    Assuming each simulated photon costs 10 rays, that means the upper limit per GPU is 
    1 billion photons/second.

 




:small:`Assistance : Geant4 Collab. + Dark Matter Search Community + NVIDIA`
------------------------------------------------------------------------------------

.. sidebar:: :small:`Assistance from NVIDIA engineers`

   .. class:: small

       :b:`Organized by interested experiments`

       **LBNL + LZ** : 2021 

       7 meeting series
         OptiX 7 API migration

       **Univ. Manchester + LHCb-RICH** : 2022 

       UK GPU Hackathon
         optimization guidance


.. class:: small

    **Geant4 11.0+ (Dec 2021) : Opticks Advanced Example** 

    * **CaTS : Calorimeter and Tracker Simulation**

      * for Liquid Argon TPC, eg DUNE

    * :r:`Hans Wentzel, Fermilab Geant4 Group`
    * *...demonstrates how to use Opticks for the creation and propagation of optical photons...*
    * https://geant4.web.cern.ch/download/release-notes/notes-v11.0.0.html


    **Dark Matter Search Community (XENON,LZ,DARWIN,..)** 

    Dark-matter And Neutrino Computation Explored (DANCE) 

    * Input to Snowmass 2021
    * https://arxiv.org/pdf/2203.08338.pdf
    * *...Opticks package may provide a solution to the tracking of optical photons...*


.. class:: center

    :r:`Great interest in Opticks => Lots of help from NVIDIA (~3 Trillion Dollar company)`


.. s5_talk::


    Due to the considerable interest in Opticks from many groups
    I have been fortunate to receive lots of help from NVIDIA engineers. 

    The Fermilab Geant4 Group was an early adopter of Opticks and has assisted by 
    developing a Geant4 advanced example demonstrating Opticks which 
    has been in the Geant4 distribution since 2021. 

    A group of experiments from the Dark Matter search community 
    made a significant contribution to Opticks development by organizing 
    a series of meetings with NVIDIA engineers that were very useful to 
    guide a re-implementation of Opticks to work with a completely new OptiX API. 
   

.. comment

    https://gitlab.cern.ch/geant4/geant4/-/tree/master/examples/advanced/CaTS 



 




 

.. comment

    :small:`CPU vs GPU architectures, Latency vs Throughput`
    ------------------------------------------------------------

    .. class:: small

        .. image:: nvidia/cpu_vs_gpu_architecture.png
           :width: 800px
           :align: center

    .. class:: small

       Waiting for memory read/write, is major source of latency...

       **CPU : latency-oriented : Minimize time to complete single task** : :red:`avoid latency with caching` 
           * complex : caching system, branch prediction, speculative execution, ...

       **GPU : throughput-oriented : Maximize total work per unit time** : :red:`hide latency with parallelism` 
           * many simple processing cores, hardware multithreading, SIMD (single instruction multiple data)
           * simpler : :green:`lots of compute (ALU)`, at expense of cache+control
           * design assumes :red:`abundant parallelism`

       Effective use of **Totally different processor architecture** -> :red:`Total reorganization of data and computation`  
           

    .. class:: tiny

        Understanding Throughput-oriented Architectures
        https://cacm.acm.org/magazines/2010/11/100622-understanding-throughput-oriented-architectures/fulltext

    .. s5_talk::

       SMALL

       * The way latency is handled is the primary thing that distinguishes the GPU from the CPU
       * the crucial thing is that the parallelism of the task is the founding "assumption" of the design of GPUs 

       **Many dont realize quite how extremely parallel you can and should go**

       * i am not just talking a few thousand threads here, millions is better
       * the largest launch I have done is 400M threads limited by VRAM 
       * best way to really experience this is to develop graphics applications 
       * they really do run billions of small shader programs per second

       I recall my first experience of the visualization 
       performance of triangulated DayaBay geometry  
       drawn with a single OpenGL draw call, using a single VBO (vertex buffer object).
       It was shockingly smooth.
       
       What is perhaps not so commonly experienced is how extremely parallel  
       tasks need to be to make best use of the GPU. 

    .. comment

       Latency hiding works using hardware multi-threading, so when one group of threads is blocked
       waiting to read from global memory for example : other groups of thread and be resumed. This 
       is only effective at hiding latency when there are enough other threads in flight at the same time.

       Porting CPU code to run on the GPU : is not a straightforward thing to do, because the archirecture is totally 
       different.  To make effective use of GPUs requires a total reorganization of data and compute. 






    
.. comment

    :small:`Validation of Opticks Simulation by Comparison with Geant4`  
    --------------------------------------------------------------------


    .. sidebar:: :small:`Random Aligned Bi-Simulation`

        .. class:: small

            Same inputs to *Opticks* and *Geant4*:

            * CPU generated photons 
            * GPU generated randoms, fed to *Geant4*

            Common recording into *OpticksEvents*:

            * compressed photon step record, up to 16 steps
            * persisted as *NumPy* arrays for python analysis   

            Aligned random consumption, direct comparison:

            * ~every **scatter, absorb, reflect, transmit** 
              at matched positions, times, polarization, wavlen



    .. class:: small


       **Bi-simulations of all JUNO solids, with millions of photons**

       mis-aligned histories
           mostly < 0.25%, < 0.50% for largest solids    
           
       deviant photons within matched history
           < 0.05% (500/1M) 
     
       **Primary sources of problems**

       * grazing incidence, edge skimmers
       * incidence at constituent solid boundaries 


       **Primary cause : float vs double** 
          
       *Geant4* uses *double* everywhere, *Opticks* only sparingly (observed *double* costing 10x slowdown with RTX) 

       **Conclude** 

       * :blue:`neatly oriented photons more prone to issues than realistic ones`
       * perfect "technical" matching not feasible
       * instead shift validation to more realistic full detector "calibration" situation    


    .. s5_talk::

       Aligned bi-simulation very efficiently finds discrepancies. Because it 
       is a direct comparison unclouded by statistical variation : so issues show up 
       very clearly.   

       Comparing individual solids shows discrepancies at the fraction of a percent level.

       Main cause is float vs double. 




.. comment

    :i:`scan-pf-check-GUI-TO-SC-BT5-SD`
    --------------------------------------

    .. s5_talk::

       This GUI allows interactive selection between tens of millions 
       of photons based on their histories.  

       Here its showing the photons that scattered before boundary transmitting straight 
       through to surface detect.

       Its implemented by indexing the photon histories using some very fast 
       GPU big integer sorting provided by CUDA Thrust, 
       and using OpenGL shaders to switch between selections.

       The 64-bit integers hold up to 16 4-bit flags for each step of the photon.

       All of this is done using interop capabilities of OpenGL/CUDA/Thrust and OptiX
       so GPU buffers can be written to and rendered inplace with no copying around.


    :i:`scan-pf-check-GUI-TO-BT5-SD`
    ----------------------------------

    .. s5_talk::

       The GUI also provides interactive time scrubbing of the propagation 
       of tens of millions of photons. 

       This is some nanoseconds later for a different history category. 
      
       I created this GUI to help with debugging the simulation. 


    .. comment

         * DELL Precision 7920T Workstation
         * Intel Xeon Silver 4114, 2.2GHz, 40 cores, 65G 
         * NVIDIA Quadro RTX 8000, 48G 

         * DELL Precision 7920T Workstation
         * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 65G  
         * NVIDIA TITAN RTX, 24G
         * NVIDIA TITAN V, 12G




.. comment

    :small:`Performance : Scanning from 1M to 400M Photons`  
    ---------------------------------------------------------------

    .. sidebar:: :small:`Test Hardware + Software`

         .. class:: small

             **Workstation**

             * DELL Precision 7920T Workstation
             * Intel Xeon Gold 5118, 2.3GHz, 48 cores, 62G  
             * NVIDIA Quadro RTX 8000 (48G) 
        
             **Software**

             * Opticks 0.0.0 Alpha 
             * Geant4 10.4p2 
             * NVIDIA OptiX 6.5.0
             * NVIDIA Driver 435.21
             * CUDA 10.1

             **IHEP GPU Cluster**

             * 10 nodes of 8x NVIDIA Tesla GV100 (32G) 




        .. class:: small

         **Full JUNO Analytic Geometry j1808v5**

         * "calibration source" genstep at center of scintillator

         **Production Mode : does the minimum**

         * only saves hits  
         * skips : genstep, photon, source, record, sequence, index, ..
         * no *Geant4* propagation (other than at 1M for extrapolation)

         **Multi-Event Running, Measure:**

         :red:`interval` 
           avg time between successive launches, including overheads:
           (upload gensteps + :blue:`launch` + download hits)

         :blue:`launch` 
           avg of 10 OptiX launches


         * overheads < 10% beyond 20M photons



    .. s5_talk::

       Emitting millions of photons from the center of the scintillator 
       and timing the interval and launch times of the propagation 
       provides a measure of the performance of a geometry.
       
       By interval, I mean the time between suceessive launches : so this 
       covers all the overheads of copying the gensteps to the GPU and 
       pulling back the hits to the CPU.

       Overheads are less than 10%    



.. comment

    .. sidebar:: :small:`Genstep/Hit Copying Overheads`

         .. class:: small

             **launch**
               time of each OptiX launch (avg of 10)

             **interval, including overhead**
               time between subsequent launches (avg of 9)

             :red:`Mostly < 10% Overhead beyond 20M photons`






:i:`scan-pf-1_NHit`
---------------------

.. raw:: html

     <pre>








     </pre>


.. sidebar:: :small:`Photon Launch Size : VRAM Limited`

     .. class:: small


         **NVIDIA Quadro RTX 8000 (48 GB)**

         * photon 4*4 floats : 64 bytes
         * curandState       : 48 bytes 

         **400M photons** x :blue:`112 bytes` ~ 45G  



.. s5_talk::

    The first check is that you get the expected number of hits 
    as a function of the number of photons.

    The photon parameters takes 64 bytes and curandState takes 48 bytes
     
    So thats 112 bytes per photon, so the limit on the number 
    of photons that can be simulated in a single launch with this 48G 
    GPU is a bit more than 400M.


:i:`scan-pf-1_Opticks_vs_Geant4 2`
------------------------------------

.. raw:: html

    <pre>
   


 
    </pre>


.. class:: small

    .. table:: 
        :align: center

        +--------------------+----------------------------+------------------+
        | JUNO analytic, 400M photons from center         |  Speedup         |
        +====================+============================+==================+
        | Geant4 Extrap.     | 95,600 s (26 hrs)          |                  | 
        +--------------------+----------------------------+------------------+
        | Opticks RTX ON (i) | 58 s                       |   1650x          |
        +--------------------+----------------------------+------------------+


.. s5_talk::

   This compares the extrapolated Geant4 propagation time with the Opticks launch
   interval with RTX on.   The speedup is more than a factor of 1000.   Need to 
   use a log scale to make them both visible. 

   For 400M photons, Geant4 takes more than a day, Opticks takes less than a minute.   

   This is with analytic geometry. Speedup is a lot more with triangles.



:i:`scan-pf-1_Opticks_Speedup 2`
---------------------------------

.. raw:: html
  
     <pre>









     </pre>

.. class:: small

     .. table:: 
        :align: center

        +-------------------------+------------------+------------------+
        | JUNO analytic, 400M photons from center    |   Speedup        |
        +=========================+==================+==================+
        | Opticks RTX ON (i)      | 58s              |   1650x          |
        +-------------------------+------------------+------------------+
        | Opticks RTX OFF (i)     | 275s             |   350x           |
        +-------------------------+------------------+------------------+
        | Geant4 Extrap.          | 95,600s (26 hrs) |                  |
        +-------------------------+------------------+------------------+


.. s5_talk::

    This is the same information shown as a ratio.




:small:`"Foundry" Model : Shared CPU/GPU Geometry Context`
-----------------------------------------------------------------------------------------------------

.. sidebar:: :small:`IAS < Inst < Solid < Prim < Node`

    .. class:: small

        * **Inst** : 4x4 tran. + **Solid** ref. ( **Inst** -> 1 **IAS** )
        * **Solid** : 1 or more **Prim**  : ( **Solid** -> **GAS** )
        * **Prim** : 1,3,7,15,31,... **Node**  : (**Prim** ~ *G4VSolid*) 

    .. raw:: html

        <pre class="mypretiny">
        struct CSGFoundry
        {
           void upload(); <span class="redbold">// to GPU </span> 
        ...
           std::vector&lt;CSGSolid&gt;  solid ; // compounds (eg PMT)
           std::vector&lt;CSGPrim&gt;   prim ;
           std::vector&lt;CSGNode&gt;   node ; // shapes, operators

           std::vector&lt;float4&gt; plan ; // planes
           std::vector&lt;qat4&gt;   tran ; // CSG transforms
           std::vector&lt;qat4&gt;   itra ; // inverse CSG transforms
           std::vector&lt;qat4&gt;   inst ; // instance transforms

           <span class="redbold">// entire geometry in four GPU allocations</span>
           CSGPrim*    d_prim ; 
           CSGNode*    d_node ; 
           float4*     d_plan ; 
           qat4*       d_itra ;    
         };
        </pre>

    .. class:: small

        :bluebold:`referencing by offset, count`  

.. class:: small

    **Geometry model designed for CPU/GPU**

    * very different to Geant4 model (dense tree of C++ objects)
    * :r:`replaces geometry context dropped in OptiX 6->7` 
    * array-based -> simple, inherent serialization + persisting 
    * entire geometry in 4 GPU allocations 

    **Simple CPU/GPU intersect headers** 

    :b:`https://github.com/simoncblyth/opticks/tree/master/CSG` 
        **csg_intersect_tree.h/csg_intersect_node.h/...**


.. raw:: html

    <pre>

    </pre>

.. class:: tiny

   **GAS** : Geometry Acceleration Structure

   **IAS** : Instance Acceleration Structure
   
   **CSG** : Constructive Solid Geometry 


.. s5_talk::

   SMALL 
   The Foundry geometry model comprises : Inst, Solid, Prim and Node

   Starting from the bottom:

   * the Node are CSG constituent shapes or operators
   * the Prim reference a range of Node forming serialized complete binary trees
   * the Solid reference one or more Prim
   * the Inst reference one or more Solid 

   **Prim:** are equivalent to G4VSolid

   **Solid:** are compound Prim, each type of PMT corresponds to a Solid 

   **Inst:** are 4x4 transforms with index refererences to Solid 

   The model is designed to work with the OptiX 7 acceleration structures:

   * Solid -> GAS (Geometry Acceleration Structure)
   * Inst  -> IAS (Instance Acceleration Structure)

   The JUNO geometry of 300,000 volumes is factorized into 10 Solid which 
   are referenced from a single instance acceleration structure. 
    
   The array-based simplicity makes it fast to upload to GPU, 
   with the entire geometry in 4 GPU allocations. 




.. comment

    Translation, initially 2 step::

               X4      CSG_GGeo
        Geant4 --> GGeo -->  CSG   

    Later one step::
 
                U4/tree
        Geant4 -> stree/CSG 




.. comment

    :small:`Two-Level Hierarchy : Instance transforms (IAS) over Geometry (GAS)`
    -------------------------------------------------------------------------------

    .. class:: small

        **OptiX supports multiple instance levels : IAS->IAS->GAS** BUT: :redbold:`Simple two-level is faster` : :red:`works in hardware RT Cores` 


    .. class:: small

        .. figure:: nvidia/tlas_blas_two_level_hierarchy.png
            :width: 800px
            :align: right 

            https://developer.nvidia.com/blog/introduction-nvidia-rtx-directx-ray-tracing/

    .. class:: small

       AS
          Acceleration Structure

       **IAS** (aka TLAS) 
          :b:`4x4 transforms, refs to GAS`
           
       **GAS** (aka BLAS)
          | :b:`custom primitives : AABB` 
          | triangles : vertices, indices

       AABB
          axis-aligned bounding box 


       **SBT : Shader Binding Table**

       Flexibly binds together:
     
       1. geometry objects
       2. shader programs 
       3. data for shader programs

       **Hidden in OptiX 1-6 APIs**



    .. s5_talk::

       OptiX uses the terms : IAS and GAS for instance and geometry acceleratiom structures.
       The other APIs use terms: TLAS and BLAS for top level and bottom level acceleration structures
       This is because OptiX supports multiple instance levels. 
       But the simple two level is faster as that can be done on the RT cores.

       Simple two-level hierarchy : **just one set of instances with transforms and references to geometry**  







.. comment

    :small:`Primary Packages and Structs Of Re-Implemented Opticks`
    -----------------------------------------------------------------

    .. sidebar:: :small:`Flexible Multi-Package Organization`

        .. class:: small

             **Code Organized by Dependency (not "Topic")**
         
             * :r:`maximizes: utility, re-use, ease of testing` 
             * => "GPU" code usable+tested on CPU 

             **Many small header-only implementations** 

             * common CPU/GPU headers   



    .. class:: small 

       *SysRap* : many small CPU/GPU headers
         * *stree.h,snode.h* : geometry base types
         * *sctx.h* *sphoton.h* : event base types
         * *NP.hh* : serialization into NumPy .npy format files     

       *QUDARap* 
         * *QSim* : optical photon simulation steering
         * *QScint,QCerenkov,QProp,...* : modular CUDA implementation 

       *U4*
         * *U4Tree* : convert geometry into *stree.h*
         * *U4* : collect gensteps, return hits 

       *CSG*
         * *CSGFoundry/CSGSolid/CSGPrim/CSGNode* geometry model
         * *csg_intersect_tree.h* *csg_intersect_node.h* *csg_intersect_leaf.h* : CPU/GPU intersection functions 

       *CSGOptiX*
         * *CSGOptiX.h* : manage geometry convert from *CSG* to OptiX 7 *IAS* *GAS*, pipeline creation
         * *CSGOptiX7.cu* : compiled into ptx that becomes OptiX 7 pipeline

           * includes QUDARap headers for simulation   
           * includes *csg_intersect_tree.h,..* headers for CSG intersection    
         
       *G4CX*
         * *G4CXOpticks* : Top level Geant4 geometry interface


    .. s5_talk::

       [HMM: COULD SKIP THIS ONE?]

       Opticks code is split into multiple packages by-dependency, not by-topic
       This means that more of the code has less dependencies, making 
       it more useful and easier to test.   

       Using mocking,  most of the "GPU" code can be tested on CPU.  

       [Notes: <30s slide, mainly for offline consumption, no need to read out]



.. comment

    :small:`Full re-implementation of Opticks for NVIDIA OptiX 7 API` 
    --------------------------------------------------------------------

    .. class:: small

        * :r:`Huge change unavoidable from new OptiX API` --> :b:`So profit from rethink of simulation code` --> **2nd impl advantage** 

        +------------------------------------------+--------------------------------------------------------+
        |  Old simulation (OptiXRap)               |  New simulation (QUDARap/qsim.h + CSGOptiX, CSG)       | 
        +==========================================+========================================================+
        |  * implemented on top of old OptiX API   | * pure CUDA implementation                             |
        |                                          | * :r:`OptiX use kept separate, just for intersection`  |
        |                                          |                                                        |
        +------------------------------------------+--------------------------------------------------------+
        |  * monolithic .cu                        | * many small headers                                   |
        |  * GPU only implementation               | * many GPU+CPU headers                                 |
        |  * deep stack of support code            | * shallow stack : QUDARap depends only on SysRap       | 
        +------------------------------------------+--------------------------------------------------------+
        |  * most code in GPU only context,        | * strict code segregation                              |
        |    even when not needing OptiX or CUDA   |                                                        |
        |                                          |   * :r:`code not needing GPU in SysRap not QUDARap`    |
        +------------------------------------------+--------------------------------------------------------+
        |  * testing : GPU only, coarse            | * :r:`testing : CPU+GPU , fine-grained`                |
        |                                          | * curand mocking on CPU                                | 
        +------------------------------------------+--------------------------------------------------------+
        |  * limited CPU/GPU code sharing          | * maximal sharing : SEvt.hh, sphoton.h, ...            |
        +------------------------------------------+--------------------------------------------------------+
        |  * timeconsuming manual random alignment | * :b:`new systematic approach to random alignment`     |  
        |    conducted via debugger                |                                                        |
        +------------------------------------------+--------------------------------------------------------+

        **Goals of re-implementation : flexible, modular GPU simulation, easily testable, less code**

        * code reduction, sharing as much as possible between CPU and GPU
        * fine grained testing on both CPU and GPU, with GPU curand mocking 
        * profit from several years of CUDA experience, eg QSim.hh/qsim.h host/device counterpart pattern:

          * hostside initializes and uploads device side counterpart --> :r:`device side hits ground running` 


    .. s5_talk::

        Embracing the change : might as well profit from a rethink 

        [Notes: dont read out as too much text, just read a few of the highlighted]









:small:`QUDARap : CUDA Optical Simulation Implementation`
------------------------------------------------------------

.. sidebar:: :small:`CPU Pre-Init of GPU Counterpart`

    .. class:: small

        hh
           instanciate device .h **on host**, upload constituents (eg texture buffers),  
           set constituent device pointers into .h instance, upload .h instance to GPU  
        h
           simple device header, testable on CPU 
            
        --> :r:`device side hits ground running` 


.. class:: small

    **CPU/GPU Counterpart Code Organization for Simulation**

    +-------------------------------+-----------------+-----------------------+
    |                               | CPU             | GPU                   |
    +===============================+=================+=======================+
    | context steering              | QSim.hh         |  qsim.h               |  
    +-------------------------------+-----------------+-----------------------+
    | curandState setup             | QRng.hh         |  qrng.h               |
    +-------------------------------+-----------------+-----------------------+
    | property interpolation        | QProp.hh        |  qprop.h              |
    +-------------------------------+-----------------+-----------------------+
    | event handling                | QEvent.hh       |  qevent.h             |
    +-------------------------------+-----------------+-----------------------+
    | Cerenkov generation           | QCerenkov.hh    |  qcerenkov.h          |
    +-------------------------------+-----------------+-----------------------+
    | Scintillation generation      | QScint.hh       |  qscint.h             |
    +-------------------------------+-----------------+-----------------------+
    | texture handling              | QTex.hh         |  cudaTextureObject_t  |
    +-------------------------------+-----------------+-----------------------+
    

    * :r:`facilitate fine-grained modular testing` 
    * bulk of GPU code in simple to test headers 

      * test most "GPU" code on CPU,  eg using mock curand

    * *QUDARap* does not depend on OptiX -> more flexible -> simpler testing    



.. s5_talk::

    Of course in addition to geometry intersections the simulation also 
    needs the optical physics. The QUDARap package is a pure CUDA port 
    of the Geant4 optical simulation, with no OptiX dependency. 

    [Notes: mainly of intersect for people writing CUDA code, a useful pattern] 


.. comment

       +---------------------------------------+
       | **A** (GPU) CSGOptiX/qsim.h           |
       +=======================================+
       |  qsim => sctx/sevent/SEvt             |
       +---------------------------------------+

       +---------------------------------------+
       | **B** (CPU) U4Recorder                |
       +=======================================+
       | G4StepPoint => sctx/sevent/SEvt       |
       +---------------------------------------+



:small:`Validation of Opticks Simulation(A) by Comparison with Geant4 Sim. (B)`
--------------------------------------------------------------------------------

.. sidebar:: :small:`A+B photon histories => SEvt`

   .. class:: small

      * **A** : CSGOptiX : qsim => SEvt
      * **B** : U4Recorder : G4StepPoint => SEvt 

      +---------------------------------------+
      | **Opticks Event** : sysrap/SEvt.hh    |
      +=======================================+ 
      | sevent.h sctx.h sphoton.h srec.h ...  |
      +---------------------------------------+
      | :r:`serialize to NumPy .npy arrays`   |
      +---------------------------------------+

      => A-B comparison, matplotlib/pyvista plotting

      +------------+------------+------------------+
      |  array     | shape      |  notes           |  
      +============+============+==================+
      | inphoton   | (n,4,4)    | input photons    |
      +------------+------------+------------------+
      | photon     | (n,4,4)    | final photons    |
      +------------+------------+------------------+
      | record     | (n,32,4,4) | photon histories |
      +------------+------------+------------------+
      | seq        |  (n,2,2)   | uint64 histories |   
      +------------+------------+------------------+
      | aux        | (n,32,4,4) | extra point info |       
      +------------+------------+------------------+
      | sframe     | (4,4,4)    | target M2W W2M   |
      +------------+------------+------------------+

      :b:`Record of every point of every photon`


.. class:: small 

   **A and B always same photon counts (due to gensteps)** 

   1. direct comparison when simulations are random aligned
   2. when not aligned : statistical Chi2 history comparison

      * compare history frequencies, Chi2 points to issues

   **Primary Issue : double vs float, also:**

   * geometry bugs : overlaps, coincident faces 
   * grazing incidence, edge skimmers

   After debugged : :b:`fraction of percent diffs` 



   

.. s5_talk::

    The Opticks simulation is validated by comparison with the Geant4 simulation. 

    Full details of the optical photon propagations from both simulations 
    are collected into Opticks Events and persisted to NumPy arrays. 
    Allowing NumPy analysis to compare the photon propagations. 




.. comment

   **Optical Performance : Very dependent on geometry + modelling**

   After avoiding geometry problems : G4Torus, deep CSG trees

   * :r:`have achieved > 1500x Geant4 [1]` 
   * :b:`removes optical bottlenecks : memory + processing` 

   .. class:: tiny 

      [1] Single threaded Geant4 10.4.2, NVIDIA Quadro RTX 8000 (48G), 1st gen RTX, ancient JUNO geom, OptiX 6.5, ancient Opticks 
     



:small:`Optical Simulation Comparison : Statistical OR Direct`
----------------------------------------------------------------

.. class:: small

    Statistical Chi-squared comparison of photon history occurence between two simulations

    * powerful metric to find discrepancies between simulations (eg from near-degenerate geometry)

.. raw:: html
 
    <pre class="mypretiny">
    c2sum/c2n:c2per(C2CUT)  280.88/188:1.494 (30)

    np.c_[siq,_quo,siq,sabo2,sc2,sabo1][0:25]  ## A-B history frequency chi2 comparison 
        0   TO BT BT BT BT SD                                             33322  33343    0.0066        1      2  
        1   TO BT BT BT BT SA                                             28160  28070    0.1441        8      0  
        2   TO BT BT BT BT BT SR SA                                        6270   6268    0.0003    10363  10565  
        3   TO BT BT BT BT BT SA                                           4552   4649    1.0226     8398   8433  
        4   TO BT BT BT BT BT SR BR SR SA                                  1154   1186    0.4376    21156  21014  
        5   TO BT BT BT BT BT SR BR SA                                      923    989    2.2782    20241  20201  
        6   TO BT BT BT BT BR BT BT BT BT BT BT AB                          946    958    0.0756    10389   8432  
        7   TO BT BT BT BT BT SR SR SA                                      901    942    0.9121    10399  10410  
        8   TO BT BT AB                                                     878    895    0.1630       26    102  
        9   TO BT BT BT BT BT SR BT BT BT BT BT BT BT AB                    615    635    0.3200    20974  22027  
       10   TO BT BT BT BT BR BT BT BT BT AB                                571    601    0.7679     8459   9208  
       11   TO BT BT BT BT BR BT BT BT BT BT BT BT BT SA                    533    537    0.0150     7312   7299  
       <span class="r">12   TO BT BT BT BT BR BT BT BT BT BT BT BT BT BT BT BT BT SD        503    396   12.7353    12018  11465</span>  
       13   TO BT BT BT BT BR BT BT BT BT BT BT BT BT SD                    480    497    0.2958     7974   7967  
       14   TO BT BT BT BT BR BT BT BT BT BT BT BT BT BT BT BT BT SA        412    411    0.0012    11467  11471  
       15   TO BT BT BT BT BT SR SR SR SA                                   383    396    0.2169    10362  10368  
     </pre>

.. class:: small

    When causes of discrepancy cannot be identified statistically

    * use common input photons + aligned random consumption between simulations 
    * enable direct photon-to-photon comparison of simulations : reveals precisely where simulations diverge

    :b:`Comparison of two independent optical simulation implementations : ideal way find issues`


.. s5_talk::

    Ideal 


.. comment 


    :i:`B_V1J008_N1_ip_MOI_Hama:0:1000_yy_frame_close.png`
    ----------------------------------------------------------

    .. raw:: html

        <p style="margin-bottom:130mm;" />

    .. class:: small

        ``Green : start position (100k input photons)`` 

        ``Red : end position,  Cyan : other position``


    .. s5_talk::

        3D pyvista view of photon points here from input photons shown in green. 
        The squares indicates the target frame.


    :i:`B_V1J008_N1_ip_MOI_Hama:0:1000_b.png`
    -------------------------------------------

    .. class:: small

       |emsp| |emsp| |emsp| |emsp| |emsp| 
       |emsp| |emsp| |emsp| |emsp| |emsp| 
       |emsp| |emsp| |emsp| |emsp| |emsp| 
       |emsp| |emsp| |emsp| |emsp| |emsp| 
       |emsp| |emsp| |emsp| |emsp| |emsp| 
       ``cd ~/j/ntds ; N=1 ./ntds.sh ana``  

    .. raw:: html

        <p style="margin-bottom:150mm;" />

    .. class:: small

       :b:`Geant4/U4Recorder 3D photon points transformed into target frame, viewed in 2D`
     

    .. s5_talk::

       This is a 2D view of the target frame, showing intersection positions on the
       PMT mask and inside the PMT. 



        :i:`B_V1J008_N1_OIPF_NNVT:0:1000_gridxy.png`
        ----------------------------------------------


        ::

             export OPTICKS_INPUT_PHOTON=GridXY_X1000_Z1000_40k_f8.npy
             export OPTICKS_INPUT_PHOTON_FRAME=NNVT:0:1000

             MODE=3 EDL=1 N=0 EYE=500,0,2300 CHECK=not_first ~/j/ntds/ntds.sh ana


        .. raw:: html

            <p style="margin-bottom:110mm;" />
            

        ::

            Photon step points from grid of input photons target NNVT:0:1000 (POM:1)


        .. s5_talk::

            This is a 3D pyvista view of photon points from a grid of input photons. 
            Looking closely you can distinguish the type of PMT 
            by the size of ring inside. 


        :i:`cxr_min__eye_1,0,5__zoom_2__tmin_0.5__NNVT:0:1000_demo.jpg`
        -----------------------------------------------------------------

        ``ray traced renders : exact same geometry "seen" by simulation``


        .. s5_talk::

            This is a ray trace render targetting the same group of PMTs. 
            You can see the same pattern of PMTs from the ray trace and from the simulation. 




.. comment

         * U4Recorder writing Opticks SEvt
         * history chi2 comparison
         * random aligned running : direct comparison 
         * "simtrace" : 2D sliced geometry rendering 
         * 3D raytraced + rasterized rendering  
         * commandline controlled (reproducible) rendering 
         * radial-theta-phi "RTP" frame targetting
         * input photon running, local frame targetting
         * 0-dependency PMT data access (NP.hh)
 
:small:`Selection of DetSim issues revealed/studied using Opticks`
--------------------------------------------------------------------

.. sidebar:: :small:`Opticks DetSim/G4 tests`

    .. class:: small

         * interactive standalone tests
         * interactive ray traced geometry rendering

           * 2D slices + 3D   

         * comparison of two optical sim. impl

           * :b:`finds issues with both impl.` 

         **Some students discouraged by issues...**

         :r:`WRONG ATTITUDE:`
             
         * every issue found is progress
         * every issue fixed is more progress
         * :b:`no issues means : not at cutting edge`  
 
         +-------------------------------------------------+
         | Trouble-shooting is primary skill of developer  |
         |    exercised continuously                       |
         +-------------------------------------------------+
         



.. class:: small

   **Geometry Issues**

   * PMT_20inch_body : "cylinder - torus" neck -> polycone
   * PMT_20inch_inner : 31 node tree -> 1 node
   * AdditionAcrylic : avoid pointless CSG hole subtraction
   * profligate G4IntersectionSolid "Z-cut" PMT => actually cut tree 
   * NNVT : MaskTail impinges MaskVirtual
   * HAMA : BodySolid impinges MaskTail

   **Physics issues**

   * G4Cerenkov_modified stale/undefined sin2Theta bug
   * PMTSimParamSvc::get_pmt_ce efficiency > 1. at low theta (NNVT, NNVT_HighQE)
   * solidXJfixture : ~10/64 overlaps with fasteners
   * BirksConstant1 : 1,000,000x TOO BIG
   * PMT Optical Model (fastsim based), single PMT test reveals:

     * 4-volume PMT, 2 fakes kludge-up fastsim "region" 
     * reflected+refracted polarization incorrect
     * propagation at Pyrex (not Vacuum) speed inside PMT
     * mid-vacuum reflect, refract, absorb, detect, "tunneling" 

   * Wrong velocity after reflection/refraction 


.. s5_talk::

   * when developing a new simulation, its inevitable that will need to develop lots of tools for testing
   * many of them are directly applicable to testing DetSim and Geant4 
   * as a result I found many DetSim bugs, and developed fixes for many of them 
   * biggest fix was a re-implementation of the PMT optical model
     moving from the fastsim approach to a custom boundary process approach 
 


.. comment

    .. image:: tboolean_12_raytrace.png
       :width: 550px
       :align: left

    .. image:: tboolean_12_rasterized.png
       :width: 1000px
       :align: center

    .. image:: tboolean_12_raytrace.png
       :width: 1200px
       :align: center









:small:`Amdahls "Law" : Expected Speedup Limited by Serial Processing`
--------------------------------------------------------------------------------------------

.. sidebar:: :small:`S(n) Expected Speedup`

    .. comment

       :width: 1176px
       :height: 358px
       :width: 588px 
       :height: 179px
            
    .. image:: parallel/amdahl.png
       :width: 392px 
       :height: 112px
       :align: center


    .. class:: small

        *P* 
             parallelizable proportion
        *1-P*
             non-parallelizable portion
        *n*
             parallel speedup factor  



optical photon simulation, P ~ 99% of CPU time  

* -> potential overall speedup S(n) is 100x 
* even with parallel speedup factor >> 1000x  



**Must consider processing "big picture"**

* remove bottlenecks one by one
* re-evaluate "big picture" after each  


.. s5_talk::

   Serial Portion of processing determines the overall 
   speedup because this goes to zero 




:i:`amdahl_p_sensitive.png`
-----------------------------

.. class:: small

    .. image:: parallel/amdahl.png
       :width: 392px 
       :height: 112px
       :align: center


.. s5_talk::

   Having a large parallel speedup of 1000x or so 
   is only actually useful to overall speedup when the 
   parallel fraction is large over 98 percent or, 
   otherwise the serial portion limits performance. 



:small:`How much parellelized speedup actually useful to overall speedup?`
---------------------------------------------------------------------------

.. class:: small

   :r:`Very dependant on the parallel fraction`

   +---------------------------------------------------------------------------------------------------------------+
   |  **Theoretical Overall Speedup for various parallel fractions and parallelized speedups**                     |
   +-------------------+-------------------------------+-----------------------------------------------------------+
   |                   |   Parallelized Speedup        |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+
   | Parallel Fraction |   100x  |   1000x   | limit   |    Notes                                                  |
   +===================+=========+===========+=========+===========================================================+
   |     95%           |   17x   |   20x     |  20x    |  Little benefit beyond ~100x parallelized speedup         |
   +-------------------+---------+-----------+---------+                                                           |
   |     96%           |   20x   |   24x     |  25x    |                                                           |
   +-------------------+---------+-----------+---------+                                                           |
   |     97%           |   25x   |   32x     |  33.3x  |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+
   |     98%           |   34x   |   48x     |  50x    |  Substantial benefit from more parallelized speedup       |
   +-------------------+---------+-----------+---------+                                                           | 
   |     99%           |   50x   |   91x     | 100x    |                                                           |
   +-------------------+---------+-----------+---------+-----------------------------------------------------------+


::

    In [1]: run ~/opticks/ana/amdahl.py

    In [2]: Amdahl.Overall_Speedup(np.array([100,1000,np.inf]),0.95)
    Out[2]: array([16.807, 19.627, 20.   ])

    In [3]: Amdahl.Overall_Speedup(np.array([100,1000,np.inf]),0.99)
    Out[3]: array([ 50.251,  90.992, 100.   ])


.. s5_talk::

    This is the same information numerically 


:small:`Summary`
------------------

.. sidebar:: :small:`Extra Benefits of Adopting Opticks`

   .. class:: small

      * high performance novel visualization
      * detailed photon instrumentation, validation 
      * comparisons find issues with both simulations:
       
        * complex geometry, overlaps, bugs... 

      :r:`=> using Opticks improves CPU simulation too !!`

.. raw:: html

     <p style="margin-bottom:5mm;" />

..

  *Opticks* : state-of-the-art GPU ray traced optical simulation integrated with *Geant4*
  with automated geometry translation for use with NVIDIA OptiX 7+ API.   

.. raw:: html

     <p style="margin-bottom:15mm;" />

.. class:: normal

  * NVIDIA Ray Trace Performance continues rapid progress (2x each generation) 
  * **any simulation limited by optical photons can benefit from Opticks**
  * more photon limited -> more overall speedup (99% -> 100x)

.. s5_talk::

    Opticks brings state-of-the-art GPU ray tracing performance to optical photon 
    simulations. 

    The detailed validations needed when adopting a new simulation has a 
    hidden benefit in that detailed comparisons reveal problems with both 
    simulations. Adopting Opticks means you will 
    improve your CPU simulation whilst also giving you a GPU simulation.  
 




:small:`Hardware accelerated Ray tracing (RT Cores) in the Data Center`
-------------------------------------------------------------------------

.. sidebar:: :small:`Data Center GPUs with RT Cores`

    .. class:: small

        * :b:`An Established part of NVIDIA Lineup`

        +--------------+------------------+-----------------+  
        |              |    NVIDIA L40    | NVIDIA L4       |   
        +==============+==================+=================+
        |  Release     |   2022/10        |  2023/03        |   
        +--------------+------------------+-----------------+  
        |  GPU Arch    |   Ada Lovelace   |  Ada Lovelace   |        
        +--------------+------------------+-----------------+  
        |  VRAM        |   48 GB gddr6    | 24 GB gddr6     |   
        +--------------+------------------+-----------------+  
        |  TDP         |    300W          |  :r:`72W`       |   
        +--------------+------------------+-----------------+  
        |  Form factor |    dual slot     |  :r:`1-slot`    |   
        +--------------+------------------+-----------------+  
        | CUDA Core    |    18,176        |   7,680         |    
        +--------------+------------------+-----------------+  
        | :b:`RT Core` |:b:`142 (3rd gen)`|:b:`60 (3rd gen)`|    
        +--------------+------------------+-----------------+  
        | Tensor Core  |    568 (4th gen) |   240 (4th gen) |    
        +--------------+------------------+-----------------+  
        |  FP32        |    90.5 TFLOPS   |  30 TFLOPS      |   
        +--------------+------------------+-----------------+  
        |  FP16(*)     |    181 TFLOPS    |  121 TFLOPS     |   
        +--------------+------------------+-----------------+  
        | Predecessor  |    A40           |    T4           |   
        +--------------+------------------+-----------------+  

        (*) x2 with Sparsity 


.. class:: small


    **NVIDIA L4 Tensor Core GPU (Released 2023/03)**

    * Ada Lovelace GPU architecture
    * :r:`universal accelerator for graphics and AI workloads` 
    * :b:`small form-factor, easy to integrate, power efficient` 
    * PCIe Gen4 x16 slot without extra power
    * Google Cloud adopted for G2 VMs, successor to **NVIDIA T4**
    * **NVIDIA L4 likely to become a very popular GPU**

.. raw:: html

    <p style="margin-bottom:2cm;" />

.. class:: small

    `NVIDIA L4 Tensor Core GPU (Data Center, low profile+power)`

.. s5_talk::

    Hardware Accelerated Ray Tracing is becoming much more commonly available, 
    with NVIDIA offering a range of data center GPUs with RT cores. 

    [Notes: <20s slide, just mention above comments]

.. comment

    The current boom in interest in AI is only going to increase this trend. 

    https://www.techpowerup.com/318595/nvidia-readying-h20-ai-gpu-for-chinese-market



:small:`US restriction on export of highest performing GPUs`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`Performance Density Threshold`

    .. raw:: html

         <pre class="mypretiny">
         +----------------------------------------------------+
         | total proc. performance (TFLOPs)                   |
         | ------------------------------ < 5.92 TFLOPs mm^-2 |
         | applicable die area (mm^2)                         |
         +----------------------------------------------------+

         ([0],[1],[2] for full rule details )
         </pre>


.. sidebar:: :small:`China+HK : ~22% NVIDIA revenue (2023 Q3)`

    .. class:: small

         :r:`=> Bound to provide GPUs just below threshold`  


.. class:: small

     NVIDIA *GPUs above performance threshold require export permits*

     * NVIDIA has introduced GPUs just under threshold : L20, L2 
     * Opportunity for Huawei, Hygon, Sugon, ...

       * => more competition, better prices


     Highest performance not needed for optical photon simulation

     * optical speedup > 1000x : little impact on overall speedup
     
       * as limited by non-optical parts of simulation



.. raw:: html

     <p style="margin-bottom:2cm;" />


.. class:: tiny

     [0] https://www.theregister.com/2023/10/19/china_biden_ai/

     [1] https://public-inspection.federalregister.gov/2023-23055.pdf

     [2] https://www.sec.gov/ix?doc=/Archives/edgar/data/1045810/000104581023000217/nvda-20231017.htm


.. s5_talk::

    China is something like 20-25% of the world market for GPUs, 
    so NVIDIA has no choice : it is bound to introduce
    GPUs with specs just underneath threshold. 


.. comment

   Huawei ray tracing
   https://dl.acm.org/doi/10.1145/3613424.3614288
   https://www.mdpi.com/2076-3417/12/19/9599

   * Googling "Huawei GPU" shows HW/SW activity
   * => unclear if/when 



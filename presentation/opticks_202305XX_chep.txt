.. meta::
   :title: Opticks CHEP 2023
   :description: (2023 May) JUNO, OptiX, Opticks
   :note: 15 min including questions 

.. include:: my_s5defs.txt


.. comment

    Opticks : GPU Optical Photon Simulation using NVIDIA OptiX 7 and NVIDIA CUDA

    Opticks is an open source project that accelerates optical photon simulation by
    integrating NVIDIA GPU ray tracing, accessed via the NVIDIA OptiX 7 API, with
    Geant4 toolkit based simulations. A single NVIDIA Turing architecture GPU has
    been measured to provide optical photon simulation speedup factors exceeding
    1500 times single threaded Geant4 with a full JUNO analytic GPU geometry
    automatically translated from the Geant4 geometry. Optical physics processes of
    scattering, absorption, scintillator reemission and boundary processes are
    implemented in CUDA based on Geant4.  Wavelength-dependent material and surface
    properties as well as inverse cumulative distribution functions for reemission
    are interleaved into GPU textures providing fast interpolated property lookup
    or wavelength generation.

    In this work we describe the near complete re-implementation of geometry and
    optical simulation required to adopt the entirely new NVIDIA OptiX 7 API, with
    the implementation now directly CUDA based with OptiX usage restricted to
    providing intersects.  The new Opticks features a modular many small header
    design that provides fine grained testing both on GPU and CPU as well as
    substantial code reductions from CPU/GPU sharing.  Enhanced modularity has
    enabled CSG tree generalization to support "list-nodes", similar to
    G4MultiUnion, that improve performance for complex CSG solids.  Recent addition
    of support for interference effects in boundaries with multiple thin layers,
    such as anti-reflection coatings and photocathodes, using CUDA compatible
    transfer matrix method (TMM) calculations of reflectance, transmittance and
    absorptance is also reported.






:i:`Opticks : GPU Optical Photon Simulation using NVIDIA OptiX 7 and NVIDIA CUDA` 
========================================================================================


.. raw:: html

    <div class="mytitle">
    <header>
    <h1 style="background-color:lightgrey;text-align:center;"> 
          <i>Opticks</i> : GPU Optical Photon Simulation</br> via NVIDIA® OptiX™ 7, NVIDIA® CUDA™

        <h2 style="background-color:lightgrey;text-align:center"> Open source, https://bitbucket.org/simoncblyth/opticks </h2>
    </h1>
    </header>
    </div>

    <img style="position:absolute; top:200px; LEFT:100px; WIDTH:200px; " src="/env/presentation/juno/JUNO_logo.png"  />
    <div class="mycredit">
    <h2 style="background-color:lightgrey"> Simon C Blyth, IHEP, CAS &mdash; (Presented by Dr Tao Lin, IHEP, CAS) &mdash; CHEP, ?? May 2023</h2>
    </div>


.. s5_talk:: 

    Opticks applies state-of-the-art GPU ray tracing from NVIDIA OptiX to optical photon simulation 
    and integrates this with Geant4. This can give drastic speedups of more a factor 1000.

    This render shows the photons resulting from a muon crossing the JUNO scintillator, 
    each line represents a single photon.



Outline
----------------------------------------------------

.. image:: /env/presentation/newtons-opticks.png 
   :width: 299px
   :height: 547px 
   :align: right


.. class:: small


    .. raw:: html

       <span>&nbsp;</span>

    * Context and Problem

      * p2: Jiangmen Underground Neutrino Observatory (JUNO)
      * p3: JUNO Optical Photon Simulation Problem...
      * p4: Optical Photon Simulation ≈ Ray Traced Image Rendering

    * NVIDIA Tools to create Solution   

      * p5: NVIDIA Ampere : 2nd Generation RTX
      * p6: NVIDIA OptiX Ray Tracing Engine
      * p7: NVIDIA OptiX 7 : Entirely new thin API

    * Opticks : Introduction + New Features

      * p8,9: Geant4 + Opticks Hybrid Workflow : External Optical Photon Simulation
      * p10: New : Collection Efficiency Culling on GPU  
      * p11: New : *CSGFoundry* Geometry Model

    * Opticks : 1st JUNO Renders with NVIDIA OptiX 7 

      * p12:Ray trace renders
      * p13:Geometry factorization  
      * p15:Ray trace times for various geometries   

    * p17: Summary + Links 
    * p18: Acknowledgement : Opticks "Hackathon" Series for NVIDIA OptiX 6->7
    * p19: LZ with Opticks

    .. raw:: html
 
       <hr/>


.. s5_talk::

    The focus of this talk is recent progress on migrating Opticks
    to work with the all new NVIDIA OptiX 7 API.
    

:i:`JUNO_Intro_2`
------------------

.. s5_talk::

    JUNO will be the worlds largest liquid scintillator detector,
    with a 20 kiloton spherical volume of scintillator instrumented with  
    almost 50 thousand PMTs. The diameter of the sphere is 35 meters. 


`Optical Photon Simulation Problem...`
---------------------------------------------------------

.. raw:: html

     <pre>







     </pre>

.. sidebar:: :small:`Huge CPU Memory+Time Expense`

    .. class:: small

         **JUNO Muon Simulation Bottleneck**
           ~99% CPU time, memory constraints

         **Ray-Geometry intersection Dominates**
           simulation is not alone in this problem...

         **Optical photons : naturally parallel, simple :**
           * produced by Cherenkov+Scintillation 
           * yield only Photomultiplier hits


.. s5_talk::

   A muon travelling across the scintillator yields tens of millions 
   of optical photons, presenting memory and time challenges for simulation.

   Most of the time is taken finding intersections between photons and geometry 
   Simulation is not alone in this bottleneck.


.. comment

   Optical photons are naturally parallel : they can be considered 
   to be produced only by two processes : Cherenkov and Scintillation and we
   are interested in photons that hit the PMTs.  

   These characteristics make it straightforward integrate an external optical
   simulation.
 



:small:`Optical Photon Simulation ≈ Ray Traced Image Rendering`
-------------------------------------------------------------------------------

.. sidebar:: Not a Photo, a Calculation

    .. image:: /env/optix/samples/optix-ray-tracing-glasses.png 
       :width: 450px
       :align: right

    .. class:: tiny

        http://on-demand.gputechconf.com/siggraph/2013/presentation/SG3106-Building-Ray-Tracing-Applications-OptiX.pdf


.. class:: small


    :bluebold:`simulation` 
       photon parameters at sensors (PMTs) 

    :bluebold:`rendering` 
       pixel values at image plane


.. raw:: html

    <pre>

    </pre>


.. class:: small

    **Much in common : geometry, light sources, optical physics**

    * :redbold:`both limited by ray geometry intersection, aka ray tracing`


.. raw:: html

    <pre>

    </pre>

.. class:: small

    **Many Applications of ray tracing** :

    * advertising, design, architecture, films, games,...
    * -> huge efforts to improve hw+sw over 30 yrs


.. s5_talk::

    Ray traced image rendering in computer graphics has exactly the same bottleneck.
    Actually, there is a lot in common between optical photon simulation and ray traced image rendering.   
    Simulation gives photon parameters at PMTs, rendering gives pixel values at the image plane.

    Both these are limited by ray geometry intersection, which is also known as ray tracing.

    Ray tracing is widely used resulting in huge efforts to improve ray tracing perfromance.
    


:small:`NVIDIA Ada : 3rd Generation RTX`
--------------------------------------------------------------------------

.. class:: small

   * **RT Core** : ray trace dedicated GPU hardware

   * **NVIDIA GeForce RTX 4090 (2022)** 

     * 16,384 CUDA Cores, 24GB VRAM, USD 1599

   * Ada (2022) : :redbold:`continued ray tracing improvements` 

     * 2x ray trace over Ampere (2020), 4x with DLSS 3
     * :b:`games becoming fully simulated worlds`  
    
   * DLSS : Deep Learning Super Sampling 

     * AI upsampling, not applicable to optical simulation

.. class:: tiny

   * TOPS : Tera operations per second



.. s5_talk::

    GPU Ray Tracing performance continue to improve rapidly.
    With Ampere there is a big increase in the numbers of CUDA 
    cores at the same price points.   


.. comment

    :i:`ada_lovelace_leap_in_ray_tracing_performance_19206531.jpg`
    ----------------------------------------------------------------

    :i:`ada_lovelace_123_RTX_generations_18976718.jpg`
    -------------------------------------------------------------

    :small:`NVIDIA OptiX 7 Programs`
    ----------------------------------

    .. class:: small

       https://developer.nvidia.com/rtx/ray-tracing/optix



:small:`Hardware accelerated Ray tracing (RT Cores) in the Data Center`
-------------------------------------------------------------------------

.. sidebar:: :small:`Data Center GPUs with RT Cores`

    .. class:: small

        * :b:`An Established part of NVIDIA Lineup`

        +--------------+----------------+----------------+  
        |              |  NVIDIA L40    | NVIDIA L4      |   
        +==============+================+================+
        |  Release     | 2022/10        |  2023/03       |   
        +--------------+----------------+----------------+  
        |  GPU Arch    | Ada Lovelace   |  Ada Lovelace  |        
        +--------------+----------------+----------------+  
        |  VRAM        | 48 GB GDDR6    | 24 GB GDDR6    |   
        +--------------+----------------+----------------+  
        |  TDP         |  300W          |  :r:`72W`      |   
        +--------------+----------------+----------------+  
        |  Form factor |  dual slot     |  :r:`1-slot`   |   
        +--------------+----------------+----------------+  
        | CUDA Cores   |  18,176        |   7,680        |    
        +--------------+----------------+----------------+  
        | RT Cores     |  142 (3rd gen) |    60 (3rd gen)|    
        +--------------+----------------+----------------+  
        | Tensor Cores |  568 (4th gen) |   240 (4th gen)|    
        +--------------+----------------+----------------+  
        |  FP32        |  90.5 TFLOPS   |  30 TFLOPS     |   
        +--------------+----------------+----------------+  
        |  FP16        |  181 TFLOPS    |  242 TFLOPS    |   
        +--------------+----------------+----------------+  
        | Predecessor  |  A40           |    T4          |   
        +--------------+----------------+----------------+  



.. class:: small


    **NVIDIA L4 Tensor Core GPU (Released 2023/03)**

    * Ada Lovelace GPU architecture
    * universal accelerator for graphics and AI workloads 
    * small form-factor, easy to integrate, power efficient 
    * PCIe Gen4 x16 slot without extra power
    * adopted by Google Cloud for G2 VMs, successor to NVIDIA T4
    * likely to become a very popular GPU




:small:`NVIDIA® OptiX™ Ray Tracing Engine -- Accessible GPU Ray Tracing`
--------------------------------------------------------------------------

.. sidebar:: :small:`Flexible Ray Tracing Pipeline` 

    .. class:: small

        :g:`Green: User Programs`,  :e:`Grey: Fixed function/HW`

    .. image:: /env/presentation/nvidia/optix7/OptiX-API.png
       :width: 450px
       :align: right

    .. class:: small

        :b:`Analogous to OpenGL rasterization pipeline` 


.. class:: small

   **OptiX makes GPU ray tracing accessible**

   * :r:`Programmable GPU-accelerated Ray-Tracing Pipeline`
   * Single-ray shader programming model using CUDA
   * ray Tracing acceleration using RT Cores (RTX GPUs)
   * "...free to use within any application..."

   **OptiX features**

   * acceleration structure creation + traversal
   * instanced sharing of geometry + acceleration structures
   * compiler optimized for GPU ray tracing

.. class:: tiny

   ``https://developer.nvidia.com/rtx/ray-tracing/optix``

.. class:: small

   **User provides (Green):**

   * ray generation
   * geometry bounding boxes
   * intersect functions 
   * instance transforms

   

.. s5_talk::

   NVIDIA OptiX makes GPU ray tracing accessible 

   * it divides up the ray tracing workflow 
   * the yellow boxes represent user provided CUDA programs, including:

     * ray generation : where Opticks generates photons and steers the simulation
     * intersection : where the geometry is implemented 

   * geometry has to be translated into a GPU appropriate form



:small:`NVIDIA OptiX 7 : Entirely new thin API => Full Opticks Re-implementation`
-----------------------------------------------------------------------------------

.. sidebar:: :small:`GPU Ray Tracing APIs Converged`

    .. class:: small

        * 3 APIs (DXR,VKRay,OptiX7) over RTX 
        * Driver updates :r:`independent of application`  
        * Support new GPUs, performance improvements 

.. class:: small

    **NVIDIA OptiX 6->7** : :b:`drastically slimmed down`

    * low-level CUDA-centric thin API (Vulkan-ized)
    * headers only (no library, impl in Driver) 
    * Minimal host state,  :red:`All host functions are thread-safe`
    * GPU launches : explicit, asynchronous (CUDA streams)
    * :strike:`near perfect scaling to 4 GPUs, for free` 
    * :strike:`Shared CPU/GPU geometry context`
    * :strike:`GPU memory management`
    * :strike:`Multi-GPU support`


.. class:: small

    **Advantages of 6->7 transition**

    * More control/flexibility over everything 
    * :b:`Keep pace with state-of-the-art GPU ray tracing` 
    * Fully benefit from current + future GPUs : RT cores, RTX 

.. class:: small

    **BUT:** :r:`demanded full re-implementation of Opticks` 
     


.. s5_talk::

   * OptiX 7 is an entirely new API, dropping many features used by Opticks
   * re-implementation of large parts of Opticks is necessary
   * i will cover recent progress on this shortly



Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow
-------------------------------------------------------------

.. class:: small

    .. table::
        :align: center

        +--------------------------------------------------+
        | :b:`https://bitbucket.org/simoncblyth/opticks`   |
        +--------------------------------------------------+


.. raw:: html

    <p style="margin-bottom:13cm;" />

.. class:: small

    Opticks API : split according to dependency -- Optical photons are GPU "resident", only hits need to be copied to CPU memory 


.. s5_talk::

    This shows how Opticks is integrated with Geant4. The geometry is translated 
    and uploaded to the GPU at initialization.

    Cerenkov or Scintillation gensteps, the blue lines, are the generation parameters 
    uploaded to the GPU so optical photon generation can be done there.

    This allows the optical photon simulation to be entirely offloaded  
    to the GPU with only collected hits requiring CPU memory.
 

Geant4 + Opticks + NVIDIA OptiX 7 : Hybrid Workflow 2
--------------------------------------------------------

.. sidebar:: :small:`Offload Optical Simulation to GPU`

   .. class:: small

      * :redbold:`translate Geant4 geometry to OptiX GPU`  

        * intersect functions
        * instance transforms
        * GPU textures for mat/surf properties

      * CUDA port of Geant4 generation+propagation

        * cuRAND random number generation  


.. s5_talk::

    In general, I found that directly porting the optical physics has been straightforward.
    Most of problems and effort of Opticks been with the geometry, because the 
    geometry model needs to be very different from the deep tree of volumes of Geant4.



:small:`Full re-implementation of Opticks for NVIDIA OptiX 7 API` 
--------------------------------------------------------------------

.. class:: small

    * :r:`Huge change unavoidable from new OptiX API` --> :b:`So profit from rethink of simulation code` --> **2nd impl advantage** 

    +------------------------------------------+-----------------------------------------------------+
    |  Old simulation (OptiXRap)               |  New simulation (QUDARap/qsim.h + CSGOptiX, CSG)    | 
    +==========================================+=====================================================+
    |  * implemented on top of old OptiX API   | * pure CUDA implementation                          |
    |                                          | * OptiX use kept separate, just for intersection    |
    |                                          |                                                     |
    +------------------------------------------+-----------------------------------------------------+
    |  * monolithic .cu                        | * many small headers                                |
    |  * GPU only implementation               | * many GPU+CPU headers                              |
    |  * deep stack of support code            | * shallow stack : QUDARap depends only on SYSRap    | 
    +------------------------------------------+-----------------------------------------------------+
    |  * most code in GPU only context,        | * strict code segregation                           |
    |    even when not needing OptiX or CUDA   |                                                     |
    |                                          |   * code not needing GPU in SYSRap not QUDARap      |
    +------------------------------------------+-----------------------------------------------------+
    |  * testing : GPU only, coarse            | * testing : CPU+GPU , fine-grained                  |
    |                                          | * curand mocking on CPU                             | 
    +------------------------------------------+-----------------------------------------------------+
    |  * limited CPU/GPU code sharing          | * maximal sharing : SEvt.hh, sphoton.h, ...         |
    +------------------------------------------+-----------------------------------------------------+
    |  * timeconsuming manual random alignment | * :b:`new systematic approach to random alignment`  |  
    |    conducted via debugger                |                                                     |
    +------------------------------------------+-----------------------------------------------------+

    **Goals of re-implementation : flexible, modular GPU simulation, easily testable, less code**

    * code reduction, sharing as much as possible between CPU and GPU
    * fine grained testing on both CPU and GPU, with GPU curand mocking 
    * profit from several years of CUDA experience, eg QSim.hh/qsim.h host/device counterpart pattern:

      * hostside initializes and uploads device side counterpart --> :r:`device side hits ground running` 


.. s5_talk::

    Embrace the change : might as well profit from a rethink 




:small:`Two-Level Hierarchy : Instance transforms (TLAS) over Geometry (BLAS)`
-------------------------------------------------------------------------------

.. class:: small

    **OptiX supports multiple instance levels : IAS->IAS->GAS** BUT: :redbold:`Simple two-level is faster` : :red:`works in hardware RT Cores` 


.. class:: small

    .. figure:: /env/presentation/nvidia/tlas_blas_two_level_hierarchy.png
        :width: 800px
        :align: right 

        https://developer.nvidia.com/blog/introduction-nvidia-rtx-directx-ray-tracing/

.. class:: small

   AS
      Acceleration Structure

   TLAS (aka **IAS**) 
      4x4 transforms, refs to BLAS
       
   BLAS (aka **GAS**)
      | triangles : vertices, indices
      | custom primitives : AABB 

   AABB
      axis-aligned bounding box 


   **SBT : Shader Binding Table**

   Flexibly binds together:
 
   1. geometry objects
   2. shader programs 
   3. data for shader programs

   **Hidden in OptiX 1-6 APIs**



.. s5_talk::

   OptiX uses the terms : IAS and GAS for instance and geometry acceleratiom structures.
   The other APIs use terms: TLAS and BLAS for top level and bottom level acceleration structures
   This is because OptiX supports multiple instance levels. 
   But the simple two level is faster as that can be done on the RT cores.

   Simple two-level hierarchy : **just one set of instances with transforms and references to geometry**  



:small:`Geometry Model Translation : Geant4 => CSGFoundry => NVIDIA OptiX 7`
-------------------------------------------------------------------------------

.. sidebar:: :small:`CSGFoundry Model`

    .. class:: small

        * array-based -> simple serialization + upload
        * entire geometry in 4 GPU allocations 
        * factorized using subtree digests 

.. class:: small

    **Geant4 Geometry Model (JUNO: 300k PV)**

    +----+---------------------------+---------------------------------------------+ 
    | PV | *G4VPhysicalVolume*       | placed, refs LV                             |
    +----+---------------------------+---------------------------------------------+ 
    | LV | *G4LogicalVolume*         | unplaced, refs SO                           |
    +----+---------------------------+---------------------------------------------+ 
    | SO | *G4VSolid,G4BooleanSolid* | binary tree of SO "nodes"                   |
    +----+---------------------------+---------------------------------------------+ 

    **Opticks CSGFoundry Geometry Model**

    +---------------+--------------------------------------------------------------------+-------------------------+
    | struct        | Notes                                                              |  Geant4 Equivalent      |
    +===============+====================================================================+=========================+
    | *CSGFoundry*  | vectors of the below, easily serialized + uploaded                 | None                    |
    +---------------+--------------------------------------------------------------------+-------------------------+
    | *qat4*        | 4x4 transform refs *CSGSolid* using "spare" 4th column             |                         |
    +---------------+--------------------------------------------------------------------+-------------------------+
    | *CSGSolid*    | refs sequence of *CSGPrim*                                         | Group of nearby PV, LV  | 
    |               +--------------------------------------------------------------------+                         |
    |               | eg JUNO *CSGSolid* numPrim [3089, 5, 11, 14, 6, 1, 1, 1, 1, 130]   |                         |
    +---------------+--------------------------------------------------------------------+-------------------------+
    | *CSGPrim*     | refs sequence of *CSGNode*, root of CSG Tree of nodes              | root *G4VSolid*         |
    +---------------+--------------------------------------------------------------------+-------------------------+
    | *CSGNode*     | CSG node parameters eg JUNO ~23k *CSGNode*                         | node *G4VSolid*         |
    +---------------+--------------------------------------------------------------------+-------------------------+

    **NVIDIA OptiX 7 Geometry Acceleration Structures (JUNO: 1 IAS + 10 GAS)**

    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | IAS | Instance Acceleration Structures | JUNO: 1 IAS created from vector of ~50k *qat4* (JUNO)                   |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 
    | GAS | Geometry Acceleration Structures | JUNO: 10 GAS created from 10 *CSGSolid* (which refs *CSGPrim,CSGNode* ) |
    +-----+----------------------------------+-------------------------------------------------------------------------+ 

.. s5_talk::

   SMALL 
   The Foundry geometry model comprises : Inst, Solid, Prim and Node

   Starting from the bottom:

   * the Node are CSG constituent shapes or operators
   * the Prim reference a range of Node forming serialized complete binary trees
   * the Solid reference one or more Prim
   * the Inst reference one or more Solid 

   **Prim:** are equivalent to G4VSolid

   **Solid:** are compound Prim, each type of PMT corresponds to a Solid 

   **Inst:** are 4x4 transforms with index refererences to Solid 

   The model is designed to work with the OptiX 7 acceleration structures:

   * Solid -> GAS (Geometry Acceleration Structure)
   * Inst  -> IAS (Instance Acceleration Structure)

   The JUNO geometry of 300,000 volumes is factorized into 10 Solid which 
   are referenced from a single instance acceleration structure. 
    
   The array-based simplicity makes it fast to upload to GPU, 
   with the entire geometry in 4 GPU allocations. 




:i:`[9]cxr_i0_t8,_-1 : EXCLUDE SLOWEST`
-----------------------------------------

.. raw:: html

    <pre>



    </pre>


.. sidebar:: :small:`JUNO Opticks OptiX 7 Ray-trace`

    .. class:: small

        CSGFoundry CPU/GPU Geometry 

        * :redbold:`purely analytic CSG, no triangles` 


.. s5_talk::

   Here is one of the first JUNO renders with the OptiX 7 using the Foundry model.

   Note that there are no triangles here, this is a purely analytic ray trace with 
   the geometry that the simulation will use.



QUDARap : new Heart of Opticks Simulation
---------------------------------------------

.. sidebar:: :small:`CPU/GPU Counterpart Pattern`

    .. class:: small

        hh
           instanciate device .h on host, upload constituent instances, 
           set device pointers, upload .h instance to GPU  
        h
           keeps device header simple
            
        --> :r:`device side hits ground running` 


.. class:: small

    +-------------------------------+-----------------+-----------------+
    |                               | CPU             | GPU header      |
    +===============================+=================+=================+
    | context steering              | QSim.hh         |  qsim.h         |  
    +-------------------------------+-----------------+-----------------+
    | curandState setup             | QRng.hh         |  qrng.h         |
    +-------------------------------+-----------------+-----------------+
    | property interpolation        | QProp.hh        |  qprop.h        |
    +-------------------------------+-----------------+-----------------+
    | event handling                | QEvent.hh       |  qevent.h       |
    +-------------------------------+-----------------+-----------------+
    | Cerenkov generation           | QCerenkov.hh    |  qcerenkov.h    |
    +-------------------------------+-----------------+-----------------+
    | Scintillation generation      | QScint.hh       |  qscint.h       |
    +-------------------------------+-----------------+-----------------+
    | texture handling              | QTex.hh         |                 |
    +-------------------------------+-----------------+-----------------+
    
    Aims of counterpart code organization:

    * :redbold:`facilitate fine-grained modular simulation testing` 
    * keep bulk of GPU code in simple to test headers (some can be tested on CPU)
    * *QUDARap* does not depend on OptiX -> more flexible -> simpler testing    






:small:`Summary and Links`
----------------------------------------------------------------

.. sidebar:: :small:`Next Steps`

   .. class:: small

      * Foundry JUNO geometry validation 
      * migrate optical physics to NVIDIA OptiX 7  
      * JUNO Production validation

.. image:: /env/presentation/1px.png
   :width: 500px
   :height: 20px

..

  *Opticks* : state-of-the-art GPU ray traced optical simulation integrated with *Geant4*. 
  Geometry progress with OptiX 7 suggests integration within months is achievable.

  .. image:: /env/presentation/1px.png
     :width: 1000px
     :height: 1px

  * Efficiency culling decision moved to GPU, reducing CPU hit memory 
  * "Foundry" geometry model implemented to support NVIDIA OptiX 7 API. 
  * :redbold:`First JUNO OptiX 7 renders achieved.` 

.. table::
    :align: center

    +--------------------------------------------------+-----------------------------------------+
    | https://bitbucket.org/simoncblyth/opticks        | code repository                         |                   
    +--------------------------------------------------+-----------------------------------------+
    | https://github.com/simoncblyth/opticks/releases  | .zip .tar.gz  archives                  |
    +--------------------------------------------------+-----------------------------------------+
    | https://simoncblyth.bitbucket.io                 | presentations and videos                |
    +--------------------------------------------------+-----------------------------------------+
    | https://groups.io/g/opticks                      | forum/mailing list archive              |
    +--------------------------------------------------+-----------------------------------------+
    | email:opticks+subscribe@groups.io                | subscribe to mailing list               |
    +--------------------------------------------------+-----------------------------------------+ 


.. s5_talk::

    Summary is that : Opticks provides state-of-the-art GPU ray tracing integrated with Geant4 and that 
    there has been substantial progress with the migration to OptiX 7, 
    which is essential to keep up with the state-of-the-art.
 
    Links to get you started with using Opticks are listed here.



:small:`Acknowledgement : Opticks "Hackathon" Series for NVIDIA OptiX 6->7`
------------------------------------------------------------------------------

* Suggested and organized by LZ, LBNL, NERSC 
* ~fortnightly meetings since Feb 2021
* :r:`Valuable advice from NVIDIA engineers` 
* see next talk by Oisin Creaner, **LZ with Opticks** 


.. s5_talk::

   This work has been assisted by a series of meetings organized by LZ people.
   Its been very helpful to get advice from NVIDIA engineers 

   The next talk covers LZ usage of Opticks.


:small:`LZ with Opticks (Images from Sam Eriksen, University of Bristol)`
--------------------------------------------------------------------------


.. s5_talk::

   Here are some Opticks renders of LZ, demonstating that Opticks is not JUNO specific, 
   it is structured to work with multiple geometries. 
   Although the more complex your optically important geometry the more work you will 
   have to get good performance.



.. comment


    :white:`[7]cxr_i0_2,_-1 : ONLY NNVT PMTs`
    -------------------------------------------

    .. s5_talk::

       7 


    :white:`[10]cxr_i0_0,_-1 : ONLY GLOBAL "REMAINDER"`
    -----------------------------------------------------------

    .. s5_talk::

       10 : REMAINDER ONLY : 0,


    :white:`[9]cxr_i0_t8,_-1 : EXCLUDE SLOWEST : 2`
    ------------------------------------------------

    .. s5_talk::

       9 : EXCLUDE THE SLOW : t8



.. comment

    cxr_view
    ------------



    cxr_view_0
    ------------

    cxr_solid_r0@
    ---------------



    cxr_view_1
    ------------

    cxr_solid_r1@
    ---------------

    cxr_solid_r1p
    -------------



    cxr_view_2
    ------------

    cxr_solid_r2@
    ---------------

    cxr_solid_r2p
    -------------



    cxr_view_3
    ------------

    cxr_solid_r3@
    ---------------

    cxr_solid_r3p
    -------------



    cxr_view_4
    ------------

    cxr_solid_r4@
    ---------------

    cxr_solid_r4p
    -------------




    cxr_view_5
    ------------

    cxr_solid_r5@
    ---------------





    cxr_view_6
    ------------

    cxr_solid_r6@
    ---------------




    cxr_view_7
    ------------

    cxr_solid_r7@
    ---------------



    cxr_view_8
    ------------

    cxr_solid_r8@
    ---------------



    cxr_view_9
    ------------

    cxr_solid_r9@
    ---------------



